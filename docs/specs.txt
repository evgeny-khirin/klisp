===============================================================================
1 Basic K-Lisp features
===============================================================================
* K-Lisp is compiler and not interpreter. Programs in K-Lisp are dynamically
  compiled directly into native machine instructions. Like other Lisps, it
  supports dynamic re-definition and re-compilation of any system parts at
  runtime without stopping the system. That gives incredible possibilities for
  support and upgrade of non-stop systems.

* K-Lisp has tight integration with C. K-Lisp provides infrastructure to extend
  Lisp with C functions with minimum overflow for performance reasons or
  integration with third party C libraries. K-Lisp also provides both funcall
  function and FUNCALL macro for easy call of Lisp functions from C. Generally
  speaking, K-Lisp may be considered as metaprogramming extension of C language
  with dynamic typing and compilation. And C may be considered as low level
  extension of K-Lisp for performance purposes. K-Lisp supports loading of
  dynamically linked libraries with C-extensions at runtime.

* K-Lisp exports garbage collector (GC) API to C programs. And such significatly
  simplifies memory management in complex programs. GC is conservative.

* K-Lisp has separate namespaces for functions and variables.

* K-Lisp supports both lexical and dynamic variables binding. It has separate
  syntax for lexical and dynamic binding. All global variables are dynamically
  bound, while function parameters and local variables are lexically bound.

===============================================================================
2 K-Lisp Data Types
===============================================================================
A K-Lisp object is a piece of data used and manipulated by K-Lisp programs. For
our purposes, a type or data type is a set of possible objects.

Every object belongs to one type exactly. Objects of the same type have similar
structures and may usually be used in the same contexts. Some types have similar
properties and such belong to one category.

A few fundamental object types are built into K-Lisp. These, from which all
other types are constructed, are called primitive types.

2.1 Printed Representation and Read Syntax
==========================================
The printed representation of an object is the format of the output generated by
the K-Lisp printer (the function print) for that object. Every data type has a
unique printed representation. The read syntax of an object is the format of the
input accepted by the K-Lisp reader (the function read) for that object. This is
not necessarily unique; many kinds of object have more than one syntax.

In most cases, an object's printed representation is also a read syntax for the
object. However, some objects have no read syntax, since it does not make sense
to enter objects of these types as constants in a K-Lisp program. These objects
are printed in hash notation, which consists of the characters '#<', a
descriptive string (typically the type name followed by the name of the object),
and a closing '>'. For example:
  > #'car
  #<lambda: 0x8049b85>

Hash notation cannot be read at all, so the K-Lisp reader signals the error
invalid-read-syntax whenever it encounters '#<'.

2.2 Comments
============
A comment is text that is written in a program only for the sake of humans that
read the program, and that has no effect on the meaning of the program. In
K-Lisp, a semicolon (';') starts a comment if it is not within a string or
character constant. The comment continues to the end of line. The K-Lisp reader
discards comments; they do not become part of the K-Lisp objects which represent
the program within the K-Lisp system.

2.3 Primitive Types
====================
2.3.1 Null Type
===============
Null object is object without value. In K-Lisp both symbol nil and empty list ()
are used to represent object of null type. They are handled by K-Lisp reader and
translated into object of type null.  Null object is used by K-Lisp as
termination element of proper list, as empty list and as logical truth value
false. k-Lisp prints null object as symbol nil.

2.3.2 Generalized Booleans
==========================
There is no boolean type in K-Lisp. Boolean false is represented by nil. In
contexts where a boolean truth value is expected, any non-nil value is
considered to be true. However, symbol 't' is the preferred way to represent the
truth value true. Symbol 't' is evaluated into itself.

2.3.3 Character Type
====================

There is no special character data type in K-Lisp. All characters are
represented by integers. Although K-Lisp supports syntax for two kinds of
characters - byte characters and UTF-32 characters. Byte characters are integers
in range 0-255. UTF-32 characters are integers in range 0-4294967295. But this
is syntax only and K-Lisp reader returns intefer after reading and validating
characters. K-Lisp provides functions to work with characters. Those functions
accept integers and interpret them as characters. They also ensure that integer
corresponds to valid character.

2.3.3.1 Byte Character Syntax
=============================
The usual read syntax for alphanumeric ASCII characters is #" followed by character and ". For
example:
  #"A"       ; character A
  #"b"       ; character b
You can express the characters bell, backspace, tab, newline, vertical tab,
formfeed, return, backslash, del, and escape as #"\a", #"\b", #"\t", #"\n",
#"\v", #"\f", #"\r", #"\\", #"\d", and #"\e", respectively. Double quote can be
represnted as #"\"" or #""". Thus,
  #"\a" - code 7, name - bell
  #"\b" - code 8, name - backspace
  #"\t" - code 9, name - horizontal tab
  #"\n" - code 10, name - newline
  #"\v" - code 11, name - vertical tab
  #"\f" - code 12, name - formfeed
  #"\r" - code 13, name - carriage return
  #"\e" - code 27, name - escape
  #"\\" - code 92, name - backslash
  #"\d" - code127, name - delete
Any characters, including non-printable, may be represented as hexadecimal
#"\xhh" or #"\Xhh" or octal #"\oooo" or #"\Oooo" escape sequences.

2.3.3.2 UTF-32 Character Syntax
===============================
The syntax of UTF-32 characters, including special, is same as byte characters,
but letter u or U should follow # sign. For example:
  #U"A"       ; character A in UTF-32 encoding
  #u"b"       ; character b in UTF-32 encoding
Hexadecimal escape sequences have form with 8 hexadecimal digits "\xhhhhhhhh" or
"\Xhhhhhhhh". And octal escape sequences have form with 11 octal digits
"\oooooooooooo" or "\Oooooooooooo". Shorter hexadecimal or octal escape
sequences must be terminated by u or U letter. For, example:
  #U"\xAu" == #U"\n"
  #U"\x1bu" == #U"\e"
  #U"\X7fu" == #U"\d"

2.3.4 Integer Type
==================
Integers in K-Lisp are signed and have arbitrary precision. There are two
subtypes of integer type: fixnum and bigint. Fixnum is used to represent numbers
that fit machine word. And bigint is used to represent other numbers. K-Lisp
automatically chooses appropriate representation. Constant MOST-POSITIVE-FIXNUM
defines maximal value of fixnum data type. And constant MOST-NEGATIVE-FIXNUM
defines minimal value of fixnum data type. Bigint data type is limited by
available memory only.

The read syntax for decimal integers is a sequence of (base ten) digits with an optional
sign at the beginning.

Integers may be notated in radices other than ten. The notation
  #nnrddddd     or     #nnRddddd
means the integer in radix-nn notation denoted by the digits ddddd. More
precisely, one may write #, a non-empty sequence of decimal digits representing
an unsigned decimal integer n, r (or R), an optional sign, and a sequence of
radix-n digits, to indicate an integer written in radix n (which must be between
2 and 36, inclusive). Only legal digits for the specified radix may be used; for
example, an octal number may contain only the digits 0 through 7. For digits
above 9, letters of the alphabet of either case may be used in order. Binary,
octal, and hexadecimal radices are useful enough to warrant the special
abbreviations #b for #2r, #o for #8r, and #x for #16r. For example:
    #2r11010101     ;Another way of writing 213 decimal
     #b11010101     ;Ditto
    #b+11010101     ;Ditto
          #o325     ;Ditto, in octal radix
           #xD5     ;Ditto, in hexadecimal radix
        #16r+D5     ;Ditto
         #o-300     ;Decimal -192, written in base 8
      #3r-21010     ;Same thing in base 3
        #25R-7H     ;Same thing in base 25
      #xACCEDED     ;181202413, in hexadecimal radix

2.3.5 Floating Point Type
=========================
Floating point numbers are the computer equivalent of scientific notation; you
can think of a floating point number as a fraction together with a power of
ten. The precise number of significant figures and the range of possible
exponents is machine-specific; K-Lisp uses the C data type double to store the
value.

The printed representation for floating point numbers requires either a decimal
point (with at least one digit following), an exponent, or both. For example,
'1500.0', '1500.' '15e2', '15.0e2', '1.5E3', and '.15E4' are five ways of
writing a floating point number whose value is 1500. They are all equivalent.
Infinity is represented as case insensitive 'INF', 'Inf', 'inf' etc. Not a
number is represented as case insensitive 'NAN', 'Nan', 'nan' etc.

2.3.6 Symbol Type
=================
A symbol in K-Lisp is an object with a name. The symbol name serves as the
printed representation of the symbol. K-Lisp provides two types of symbols:
interned and uninterned. Interned symbols are far more common than uninterned
symbols, and there are more ways to create them. Interned symbols have an
external representation that is recognized by the procedure read; uninterned
symbols do not.

A symbol can serve as a variable or it may serve only to be distinct from all
other K-Lisp objects, so that its presence in a data structure may be recognized
reliably. In a given context, usually only one of these uses is intended. But
you can use one symbol in all of these ways, independently.

Symbol names are case sensitive and may consist any characters except delimiters
and must not match printed representation of objects of other types.

2.3.7 Binary Type
=================
Binary is vector of bytes. Printing representation of binary is:
  #b() - empty binary object
  #b(x ...) - where x is one or more printed representation of objects with
    following types: integer in range 0-255, character, binary or string.
    Characters and strings are converted to binary using encoding, defined by
    current locale of program thread.
Indexes of binary object are fixnums and maximal capacity of binary object defined
by BINARY-MAX-CAPACITY constant.

2.3.8 String Type
=================
String is vector of characters. The read syntax for a string is a double-quote,
an arbitrary number of characters, and another double-quote, "like this". Syntax
of characters inside of string is same as character type. Strings are multi
line, i.e. string "Hello,\nworld!" and string
"Hello,
world!"
are equal.
There is also special multistring syntax. Printing representation of
multistring is:
  #s() - empty string object - ""
  #s(x ...) - where x is one or more printed representation of objects with
    following types: character, binary or string. Binaries are converted to
    string using encoding, defined by current locale of program thread.
Multistring is useful, when it is necessory to split long string literals in
parts. For example, strings:
"-------------------------------------------------------------------------"
and
#s("-------------------------------------"
   "------------------------------------")
are equal.
Indexes of string object are fixnums and maximal capacity of string object is
defined by STRING-MAX-CAPACITY constant.

2.3.9 Cons And List Types
=========================
A cons is an object that consists of two slots, called the car slot and the cdr
slot. Each slot can hold or refer to any K-Lisp object including cons itself. We
also say that "the car of this cons cell is" whatever object its car slot
currently holds, and likewise for the cdr.

A list is a series of conses, linked together so that the cdr slot of each cons
holds either the next cons or the empty list. The empty list is actually object
of type null. Because most conses are used as part of lists, the phrase list
structure has come to refer to any structure made out of conses. Lists with nil
object in last cdr slot are called proper lists.

Because conses are so central to K-Lisp, we also have a word for "an object
which is not a cons." These objects are called atoms.

The read syntax and printed representation for lists are identical, and consist
of a left parenthesis, an arbitrary number of elements, and a right
parenthesis. Here are examples of lists:

     (A 2 "A")            ; A list of three elements.
     ()                   ; A list of no elements (the empty list).
     nil                  ; A list of no elements (the empty list).
     ("A ()")             ; A list of one element: the string "A ()".
     (A ())               ; A list of two elements: A and the empty list.
     (A nil)              ; Equivalent to the previous.
     ((A B C))            ; A list of one element
                          ;   (which is a list of three elements).

Upon reading, each object inside the parentheses becomes an element of the
list. That is, a cons is made for each element. The car slot of the cons holds
the element, and its cdr slot refers to the next cons of the list, which holds
the next element in the list. The cdr slot of the last cons is set to hold nil.

The names car and cdr derive from the history of Lisp. The original Lisp
implementation ran on an IBM 704 computer which divided words into two parts,
called the "address" part and the "decrement"; car was an instruction to extract
the contents of the address part of a register, and cdr an instruction to
extract the contents of the decrement. Conses are named for the function cons
that creates them, which in turn was named for its purpose, the construction of
cells.

2.3.9.1 Dotted Pair Notation
============================
Dotted pair notation is a general syntax for conses that represents the car and
cdr explicitly. In this syntax, (a . b) stands for a cons whose car is the
object a and whose cdr is the object b. Dotted pair notation is more general
than list syntax because the cdr does not have to be a list. However, it is more
cumbersome in cases where list syntax would work. In dotted pair notation, the
list ‘(1 2 3)’ is written as ‘(1 . (2 . (3 . nil)))’. For nil-terminated lists,
you can use either notation, but list notation is usually clearer and more
convenient. When printing a list, the dotted pair notation is only used if the
cdr of a cons is not a list.

2.3.10 Vector Type
==================
A vector is a one-dimensional array of elements of any type. It takes a constant
amount of time to access any element of a vector. (In a list, the access time of
an element is proportional to the distance of the element from the beginning of
the list.)
Indexes of vector object are fixnums and maximal capacity of vector object is
defined by VECTOR-MAX-CAPACITY constant.

Printed representation of vector is:
  #() - empty vector
  #(o ...) where o is one or more printed representation of objects of any
  type.

2.3.11 Lambda Type
==================
Lambda is name for K-Lisp function objects. K-Lisp functions are executable
code, just like functions in other programming languages. In K-Lisp, unlike most
languages, functions are also K-Lisp objects. Printed representation of lambda
object is a lambda expression: that is, a list whose first element is the symbol
lambda. For example:
  (lambda (x) (* x x))    ; functional object calculating square of number

In most programming languages, it is impossible to have a function without a
name. In K-Lisp, a function has no intrinsic name. A lambda expression can be
called as a function even though it has no name; to emphasize this, we also call
it an anonymous function. A named function in K-Lisp is just a symbol with a
valid function in its function slot.

Most of the time, functions are called when their names are written in K-Lisp
expressions in K-Lisp programs. However, you can construct or obtain a function
object at run time and then call it using usual K-Lisp syntax or with 'apply' or
'funcall' functions.

2.3.11 Macro Type
=================
A K-Lisp macro is a user-defined construct that extends the K-Lisp language. It
is represented as an object much like a function, but with different
argument-passing semantics: arguments passed to macro unevaluated, and different
invocation semantics: macros are evaluated by compiler. Macro returns K-Lisp
object, which is then compiled by K-Lisp. This process is called
macroexpansion. Macroexpansion is recursive process and performed by compiler
untill all macros within expression are expanded. Printed representation of
macro object is same as lambda expression, but first element of list is the
symbol macro. For example:
  (macro (x) `(* ,x ,x))    ; macro object expanding into inlined square of
  number

Macros may be invoked directly as regular K-Lisp function. In that case they
will be expanded by K-Lisp evaluator and resulting expression will be
evaluated. They also may be passed for evaluation to 'apply' or 'funcall'
functions.  In that case result of macro expansion is returned. That is what
macroexpand functions do, in order to expand macros.

K-Lisp guarantees that all macros will be expanded during compilation process.

2.3.12 Closure
==============
Closure is a function together with a referencing environment for the non-local
lexical variables of that function. K-Lisp has full support of lexical closure
objects and they are created by K-Lisp automatically, when necessary. For
example, in following code:
  (let ((x 0))
    (defun counter ()
      (set! x (+ x 1))))
'couter' is closure.

2.4 Read Syntax for Circular Objects (NOT IMPLEMENTED)
======================================================
To represent shared or circular structures within a complex of K-Lisp objects, you
can use the reader constructs '#n=' and '#n#'.

Use #n= before an object to label it for later reference; subsequently, you can
use #n# to refer the same object in another place. Here, n is some integer. For
example, here is how to make a list in which the first element recursed as the
third element:
  (#1=(a) b #1#)
This differs from ordinary syntax such as this
  ((a) b (a))
which would result in a list whose first and third elements look alike but are
not the same K-Lisp object. This shows the difference:
  > (set! x '(#1=(a) b #1#))
  > (eq (nth 0 x) (nth 2 x))
  t
  > (set! x '((a) b (a)))
  > (eq (nth 0 x) (nth 2 x))
  nil
You can also use the same syntax to make a circular structure, which appears as
an "element" within itself. Here is an example:
  #1=(a #1#)
This makes a list whose second element is the list itself. Here's how you can
see that it really works:
  > (set! x '#1=(a #1#))
  > (eq x (cadr x))
  t



===============================================================================
3 K-Lisp Programs
===============================================================================
3.1 REPL
========
The heart of K-Lisp programs evaluation is 'eval' function. When K-Lisp is
started in interactive mode it provides REPL (Read-Eval-Print-Loop) evaluation
environment - K-Lisp enters in loop doing following: reads expresion from
standard input, evaluates it with 'eval' function and prints result.

'eval' function treats all K-Lisp objects, except lists, as self evaluating.
Examples of self evaluating expressions:
  > "hello, world"
  "hello, world"
  > 1
  1
  > #b(1 2 3 4)
  #b(1 2 3 4)

Lists are treated as K-Lisp programs by 'eval' function and must be proper
lists. Evaluation process of K-Lisp program consists of compilation and
following invocation of compiled program. Result of program invocation is then
returned as result of eval function.  Examples of K-Lisp programs:
  > (+ 1 2)
  3
  > (lambda () "Hello!")
  #<lambda 0x7fe5762e18e0 nil>

3.2 Syntax of K-Lisp Programs
=============================
Syntax of K-Lisp is very simple. It is regular K-Lisp proper list. K-Lisp
selects rules for program evaluation, depending on first element of the
list. First element of the list is expected to be one of:
  1. Symbol representing K-Lisp special form. Each special form is syntax
     construction with its own evaluation rules for arguments and treated by
     compiler in individual way. Examples of special forms are 'if', 'setq',
     'lambda' etc.
  2. Symbol, which function slot contains lambda object. In that case, compiler
     generates function call. All arguments are evaluated in order, specified by
     program and passed to function.
  3. Symbol, which function slot contains macro object. In that case, compiler
     invokes the macro function by itself and passes to it unevaluated
     arguments. Then compiler compiles object returned by macro function in
     regular way.
  4. Proper list representing 'lambda' special form. In that case 'lambda' is
     evaluated to lambda object, and compiler generates function call for that
     object. All arguments are evaluated in order, specified by program and
     passed to function.
  5. Proper list representing 'macro' special form. In that case 'macro' is
     evaluated to macro object, and compiler invokes the macro function by
     itself and passes to it unevaluated arguments. Then compiler compiles
     object returned by macro function in regular way.

3.3 Immutable Objects
=====================
Functional objects may contain literal K-Lisp objects, like "hello", #(1 2 3)
etc, in their body or in lambda list. In order to prevent weird bugs and for
security reasons, such objects are marked as immutable by K-Lisp compiler. Any
attempt to modify them will raise error.

3.4 Global Functions and Hot Code Replacement
=============================================
Symbols with bound function slot are called global functions. Those functions
can be called by name. K-Lisp allows replacement of global function by new on
the fly, if lambda list of new function is not changed. Details are explained in
"Lambda Lists and Arguments Evaluation Order" chapter. So code calling the
function does not need to be recompiled. For example:
  > (defun f1 () 'old-f1)
  f1
  > (defun f () (f1))
  f
  > (f)
  old-f1
  > (defun f1 () 'new-f1)
  f1
  > (f)
  new-f1



===============================================================================
4 Lambda Lists and Arguments Evaluation Order
===============================================================================

Each functional object has lambda list, which specifies parameters received by
function. It may consist of required, optional, rest and keyword parameters.

The syntax for lambda lists is as follows:

    lambda-list ::= (var*
                     [&optional {var | (var [init-form])}+]
                     [&rest var]
                     [&key {var | (var | [init-form])}+])

  * Required parameters have no special preceding keyword and reside in begining
    of lambda list. They have no special syntax and specified as symbols for
    parameters names. Function may not have required parameters. And they are
    required in sence that caller of function must supply all required
    parameters.

  * Optional parameters follow '&optional' keyword after required
    parameters. They may be in one of following form: var or (var default),
    where var is symbol for parameter name and default is form. If optional
    argument is ommited in function invocation, then default form, specified in
    lambda list is evaluated and result is passed as argument to function. If
    default value is not specified, then nil is used as default form. Function
    may not have optional parameters.

  * Rest parameter follows '&rest' keyword after required and optional
    parameters. Single rest parameter is allowed, which in turn must be followed
    by another lambda list keyword or the end of the lambda list. After all
    optional parameter specifiers have been processed, then there may or may not
    be a rest parameter. If there is a rest parameter, it is bound to a list of
    all as-yet-unprocessed arguments. If no unprocessed arguments remain, the
    rest parameter is bound to the empty list. If there is no rest parameter and
    there are no keyword parameters, then an error should be signaled if any
    unprocessed arguments remain. The value of rest parameter is not necessary
    to be freshly constructed and may be immutable for modifications. For
    example, 'apply' function may reuse already constructed list of its last
    argument. Use 'list' or 'cons' functions in order to get fresh non-immutable
    list. Function may not have rest parameter.

  * Keyword parameters follow '&key' keyword after required, optional and rest
    parameters. Keyword parameters allow to pass actual arguments to function
    using order different from order in lambda list. Each keyword argument in
    function invocation must be preceeded by keyword corresponding parameter's
    name in lambda list. They may be in one of following form: var or (var
    default), where var is symbol for parameter name and default is form. If
    keyword argument is ommited in function invocation, then default form,
    specified in lambda list is evaluated and result is passed as argument to
    function. If default value is not specified, then nil is used as default
    form. Function may not have keyword parameters.

Arguments in K-Lisp are evaluated from left to right in order, specified by
program. If not all keyword arguments are supplied in function invocation, then
ommited arguments are evaluated in order specified by lambda list.

Functional object specified in function call may be evaluated before or after
evaluation of all arguments, but not in the middle of arguments evaluation.



===============================================================================
5 Special Forms
===============================================================================
Special form defines semantics of K-Lisp language. Special form is like buit-in
macro, but does not have K-Lisp object associated with it. So it is impossible
to redefine special form. When evaluator encounters symbol of special form in
place of function call in expression, it interprets it according built-in
special rules and does not checks value assotiated with that symbol.

K-Lisp tries to keep amount of special forms as small as possible.

5.1 quote
=========
The special form quote returns its single argument, as written, without
evaluating it. This provides a way to include constant symbols and lists, which
are not self-evaluating objects, in a program. (It is not necessary to quote
self-evaluating objects such as numbers, strings, and vectors.)

- Special Form: quote object

This special form returns object, without evaluating it.

Because quote is used so often in programs, K-Lisp provides a convenient read
syntax for it. An apostrophe character (') followed by a K-Lisp object (in read
syntax) expands to a list whose first element is quote, and whose second element
is the object. Thus, the read syntax 'x is an abbreviation for (quote x).

5.2 if
======
Special Form: if condition then-form [else-form]

Returns result of 'then-form' or 'else-form', depending on value of
'condition'.

If value of 'condition' is non-nil, then 'then-form' is evaluated and the result
is returned. Otherwise, the 'else-form' is evaluated and the result returned. if
'else-form' is omitted and value of 'condition' is false, then nil is returned.

5.3 lambda
==========
Special Form: lambda lambda-list expression ...

Returns new functional object. Lambda list and body automatically marked as
immutable, preventing some weird bugs and code injection.

The environment in effect when the lambda form is evaluated is remembered as
part of the procedure; it is called the closing environment. When the procedure
is later called with some arguments, the closing environment is extended by
binding the variables in the formal parameter list to fresh locations, and the
locations are filled with the arguments according to rules about to be
given. The new environment created by this process is referred to as the
invocation environment.

Once the invocation environment has been constructed, the expressions in the
body of the lambda expression are evaluated sequentially in it. This means that
the region of the variables bound by the lambda expression is all of the
expressions in the body. The result of evaluating the last expression in the
body is returned as the result of the procedure call.

Lambda special form must contain at least one expression.

5.3 macro
=========
Special Form: macro lambda-list expression ...

Returns new macro object. Lambda list and body automatically marked as
immutable, preventing some weird bugs and code injection.

Syntax of macro form is same as lambda form, with first symbol 'macro'.

5.4 setq
========
Special form: (setq {var form}+) ==> object

Parameters: var - symbol
            form - form.

Returns value of last evaluated form.

Binds variable 'var' to value of 'expression'. Variable is looked starting from
current lexical environment. If variable is not found in lexical environment,
then dynamic environment of current thread is searched. And then global
environment is searched. If symbol is not found in any environment, then error
is signaled.  Assigment is done sequentially, ie. if variable mentioned in
'setq' is used in latter forms, then new value of the variable will be used.

5.5 progn
=========
Special form: (progn exp1 exp2 ... expN) ==> object
  expressions is sequence of any K-Lisp expressions.

Returns result of last expression.

Sequencing special form: evaluates expressions in sequence as they appear and
returns result of last expression.

5.6 dynamic-let
===============
Special form: (dynamic-let (init*) body) ==> object

Syntax: init - var or (var value)
        var - symbol.
        value - form
        body - form+.

Returns result of last expression.

Performs dynamic binding of global variables. Binding performed in parallel: all
value forms are evaluated in order before any variable is bound. Body forms are
evaluated in implicit 'progn' and modified global environment. Original values
of global variables are automatically restored upon return from dynamic-let form
or stack unwinding. Child thread does not share dynamic bindings of it's parent.

5.7 let
=======
Special form: (let (init*) body) ==> object

Syntax: init - var or (var value)
        var - symbol.
        value - form
        body - form+.

Returns result of last expression.

Performs lexical binding of variables. Binding performed in parallel: all value
forms are evaluated in order before any variable is bound. Body forms are
evaluated in implicit 'progn' and modified lexical environment.

5.8 let*
========
Special form:  (let* bindings body) ==> object

Parameters: bindings - list. Bindings should have the form
                ((<variable1> <init1>) ...)
              where each <init> is an expression, and <body> should be a
              sequence of one or more expressions. It is an error for a
              <variable> to appear more than once in the list of variables being
              bound.
            body - form+.

'let*' is similar to 'let', but the bindings are performed sequentially from left to
right, and the region of a binding is that part of the 'let*' expression to the
right of the binding. Thus the second binding is done in an environment in which
the first binding is visible, and so on.

5.9 catch
=========
Special form: (catch tag exp*)

Syntax: exp - form
        tag - form

'Catch' is used as the destination of a non-local control transfer by 'throw'
function. Tags are used to find the 'catch', to which 'throw' is transferring
control. (catch 'foo form) catches a (throw 'foo form) but not a (throw 'bar
form).

The order of execution of 'catch' follows:
  1. Tag is evaluated. It serves as the name of the 'catch'.
  2. Forms are then evaluated as an implicit 'progn', and the results of the last
     form are returned unless a 'throw' occurs.
  3. If 'throw' occurs during the execution of one of the forms, control is
     transferred to the 'catch' form whose tag is 'eq' to the tag argument of the
     'throw' and which is the most recently established 'catch' with that tag. No
     further evaluation of forms occurs.
  4. The tag established by 'catch' is disestablished just before the results are
     returned.

If during the execution of one of the forms, 'throw' is executed whose tag is 'eq'
to the 'catch' tag, then the values specified by the 'throw' are returned as the
result of the dynamically most recently established 'catch' form with that tag.
The mechanism for 'catch' and 'throw' works even if 'throw' is not within the lexical
scope of 'catch'. 'throw' must occur within the dynamic extent of the evaluation of
the body of a 'catch' with a corresponding tag.

5.10 throw
=========
Special form: (throw tag &optional value)

Parameters: tag - form.
            value - form.

The purpose of 'throw' is to return to a return point previously established
with 'catch'. The argument tag is evaluated and used to choose among the various
existing return points; it must be 'eq' to the value specified in the
'catch'. If multiple return points match tag, the innermost one is used. If
value form is evaluated to multiple values, then all values are passed to return
point.

If no return point is in effect with tag tag, then a no_catch error is signaled
with data (tag . value).

5.11 handler-bind
=================
Special form: (handler-bind handler body+)

Parameters: handler - function of two arguments (lambda (label value)). The
              handler will be invoked by signal function, in case of error
              signaling. Return value of handler is ignored by signal function.
            body - forms

Evaluates body in implicit progn with installed signal handler. Returns value of
last evaluated form.

5.12 handler-case
=================
Macro: (handler-case exp clauses+)

Syntax: exp - form
        clauses - label-clause | t-clause
        label-clause - (label var-binding exp+)
        label - object
        var-binding - nil | (value)
        var - symbol
        t-clause - (t t-var-binding exp+)
        t-var-binding - nil | (label value*)

'Handler-case' executes expression and catches signals generated by signal
special form. If no signals are generated by expression then value of that
expression is returned. If signals is generated by calling special form (signal
label &optional value), then signal's label is matched against labels specified in
label-clauses in turn, using 'eq' function. Labels are not evaluated. If label
is matched, then signal's value is bound to variable, specified in clause, and
clause's body is evaluated in implicit 'progn'. Rest of labels after matched one
is not matched. If var-binding is specified as nil, then clause's body is
evaluated without binding. If signal label is not matched any label-clause and
t-clause is presented, then signal is catched by t-clause and clause's body is
evaluated in implicit 'progn'. Vairables in t-clause is bound to arguments of
signal special form, generated signal.  If t-clause is not specified, then signal is
not catched by this handler and passed up to next handler. If signal is not
catched by all active handlers, then thread is terminated.

Example:
  (handler-case
    (signal 'error 36)
    (error (n) (print (list 'catched 'error n)))
    (t (label value) (print (list 'unhandled 'signal label value))))

5.13 signal
===========
Function: (signal label &optional value)

Parameters: label - symbol.
            value - object.

The function signals an error named by label. The value is additional data
relevant to the circumstances of the error. The function calls signal handlers
installed with handler-bind function. The handlers are called in reverse order -
most recently installed handler is called first etc. Since handlers are called
before stack unwinding, they may take actions to fix the error and pass control
back with 'throw' special form. In that case signal hander function does not
return and signal is handled. If signal is not handled, then function from
'*unhandled-signal-hook*' is called. If hook is not installed or is returned,
then 'signal' function terminates current thread.

5.14 flet
=========
Special form: (flet ({(function-name lambda-list function-body)}*) flet-body) ==> object

Syntax: function-name - symbol.
        lambda-list - lambda list.
        function-body - form+.
        flet-body - form+.

Returns result of last expression in flet-body.

Performs lexical binding of functions. Binding performed in parallel: all
definitions are evaluated in order before any function is bound. Flet body forms
are evaluated in implicit 'progn' and modified lexical environment.

5.15 labels
===========
Special form: (labels ({(function-name lambda-list function-body)}*) labels-body) ==> object

Syntax: function-name - symbol.
        lambda-list - lambda list.
        function-body - form+.
        labels-body - form+.

Returns result of last expression in labels-body.

Labels is equivalent to flet except that the scope of the defined function names
for labels encompasses the function definitions themselves as well as the
body. Definitions are evaluated in order.

5.16 macrolet
=============
Special form: (macrolet ({(macro-name lambda-list macro-body)}*) macrolet-body) ==> object

Syntax: macro-name - symbol.
        lambda-list - lambda list.
        macro-body - form+.
        macrolet-body - form+.

Returns result of last expression in macrolet-body.

Macrolet is equivalent to flet except that it defines local macros. Macros
objects exist during compilation of 'macrolet' special form only and are
discarded after compilation is finished. Definitions are evaluated in
order. Local macros can not be closures, because closure is created during
runtime, but macro exists and must be expanded during compilation time only.

5.17 function
=============
Special form: (function name) ==> lambda or macro

The value of function is the functional value of name in the current lexical
environment.

If name is a function name, the functional definition of that name is that
established by the innermost lexically enclosing flet, labels, or macrolet form,
if there is one. Otherwise the global functional definition of the function name
is returned. Lexically defined functional objects are evaluated in compile time,
while global function definitions are evaluated in runtime using
'symbol-function' function.

5.18 tagbody/go
===============
Special form: (tagbody body) => nil

Executes one or more statements in a lexical environment that provides for
control transfers to labels indicated by the tags. Tags are atoms on top level
of 'tagbody' form, and they are matched with 'eq' function.

The statements in a 'tagbody' are evaluated in order from left to right, and their
values are discarded. If at any time there are no remaining statements, 'tagbody'
returns nil. However, if '(go tag)' is evaluated, control jumps to the part of
the body labeled with the tag. Tags are not evaluated in 'go' and matched with
'eq' function.

A tag established by 'tagbody' has lexical scope and dynamic extent. Once
'tagbody' has been exited, it is no longer valid to 'go' to a tag in its
body. It is permissible for 'go' in local function to jump to a 'tagbody' of
enclosing function. It is called non-local go.

It is permissible for 'go' to jump to a 'tagbody' that is not the innermost
'tagbody' containing that 'go'; the tags established by a 'tagbody' only shadow
other tags with same name.

The determination of which elements of the body are tags and which are
statements is made prior to any macro expansion of that element. If a statement
is a macro form and its macro expansion is an atom, that atom is treated as a
statement, not a tag.

Example of local go:
  (tagbody
      (go start)
    trap
      (print 'trapped)
      (go end)
    start
      (go trap)
   end)

Example of non-local go:
  (tagbody
      (go start)
    trap
      (print 'trapped)
      (go end)
    start
      (funcall (lambda () (go trap)))
   end)

Example of invalid non-local go:
  (funcall (let (f)
             (tagbody
                 (go start)
               trap
                 (print 'trapped)
                 (go end)
               start
                  (setq f (lambda () (go trap)))
               end)
             f))

5.19 unwind-protect
===================
Special form: (unwind-protect protected-form cleanup-form+)

'unwind-protect' evaluates protected-form and guarantees that cleanup-forms are
executed before 'unwind-protect' exits, whether it terminates normally or is
aborted by a control transfer of some kind. 'unwind-protect' is intended to be
used to make sure that certain side effects take place after the evaluation of
protected-form.

If a non-local exit occurs during execution of cleanup-forms, no special action
is taken. The cleanup-forms of 'unwind-protect' are not protected by that
'unwind-protect'.

'unwind-protect' protects against all attempts to exit from protected-form,
including 'go', 'throw', 'signal' and 'return-from'.

5.20 symbol-macrolet
====================
Special form: (symbol-macrolet ((var value)*) body) ==> object

Syntax: var - symbol.
        value - form
        body - form+.

Returns result of last expression.

'symbol-macrolet' provides a mechanism for affecting the macro expansion
environment for symbols.

'symbol-macrolet' lexically establishes expansion functions for each of the symbol
macros named by symbols. The only guaranteed property of an expansion function
for a symbol macro is that when it is applied to the form and the environment it
returns the correct expansion.

Each reference to symbol as a variable within the lexical scope of
'symbol-macrolet' is expanded by the normal macro expansion process.  The
expansion of a symbol macro is subject to further macro expansion in the same
lexical environment as the symbol macro invocation, exactly analogous to normal
macros.

The use of 'symbol-macrolet' can be shadowed by let. In other words,
'symbol-macrolet' only substitutes for occurrences of symbol that would be in the
scope of a lexical binding of symbol surrounding the forms.

5.21 block
==========
Special form: (block name body) ==> object

Syntax: name - symbol or nil
        body - form+

'Block' establishes a block named name and then evaluates forms as an implicit
'progn'.

The special operators 'block' and 'return-from' work together to provide a
structured, lexical, non-local exit facility. At any point lexically contained
within forms, 'return-from' can be used with the given name to return control and
values from the 'block' form, except when an intervening block with the same name
has been established, in which case the outer block is shadowed by the inner
one.

The 'block' named name has lexical scope and dynamic extent.

Once established, a 'block' may only be exited once, whether by normal return or
explicit return.

5.22 return-from
================
Special form: (return-from name [value]) ==> none

Syntax: name - symbol or nil
        value - form. Default is nil.

Returns control and value from a lexically enclosing block with given name.

A 'block' form named name must lexically enclose the occurrence of
'return-from'.



===============================================================================
6 Iterations
===============================================================================
6.1 do
======
Macro: do

Syntax:
  do ({(var init-form [step-form])}*) (end-test-form result-form*) statement*

Arguments and Values:
  var - a symbol.
  init-form - a form.
  step-form - a form.
  end-test-form -a form.
  result-form - a form.
  statement - a compound form; evaluated as described below.

Returns: value of result-form

Description:
do iterates over a group of statements while a test condition holds. do accepts
an arbitrary number of iteration vars which are bound within the iteration and
stepped in parallel. An initial value must be supplied for each iteration
variable by use of an init-form. Step-forms may be used to specify how the vars
should be updated on succeeding iterations through the loop. Step-forms may be
used both to generate successive values or to accumulate results. If the
end-test-form condition is met prior to an execution of the body, the iteration
terminates.

Before the first iteration, all the init-forms are evaluated, and each var is
bound to the value of its respective init-form, if supplied. This is a binding,
not an assignment; when the loop terminates, the old values of those variables
will be restored. For do, all of the init-forms are evaluated before any var is
bound. The init-forms can refer to the bindings of the vars visible before
beginning execution of do.

At the beginning of each iteration, after processing the variables, the
end-test-form is evaluated. If the result is false, execution proceeds with the
body of the do form. If the result is true, the result-form is evaluated, and
then do returns. If result-form is not specified, then value of end-test-form
returned as result of do form.

At the beginning of each iteration other than the first, vars are updated as
follows. All the step-forms, if supplied, are evaluated, from left to right, and
the resulting values are assigned to the respective vars. Any var that has no
associated step-form is not assigned to. All the step-forms are evaluated before
any var is updated; the assignment of values to vars is done in
parallel. Because all of the step-forms are evaluated before any of the vars are
altered, a step-form when evaluated always has access to the old values of all
the vars, even if other step-forms precede it. After the vars have been updated,
the end-test-form is evaluated as described above, and the iteration continues.

Example:
  (do ((temp-one 1 (1+ temp-one))
       (temp-two 0 (1- temp-two)))
      ((> (- temp-one temp-two) 5) temp-one)
    (print (list temp-one temp-two))) ==>  4

6.2 do*
=======
Macro: do*

Syntax:
  do* ({(var init-form [step-form])}*) (end-test-form result-form*) statement*

This macro is same as 'do', but bindings and stepping are done sequentially.

6.3 dotimes
===========
Macro: (dotimes (var count-form [result-form]) body)

Parameters: var - symbol.
            count-form - form.
            result-form - form.
            body - form+.

Dotimes iterates over a series of integers.

Dotimes evaluates count-form, which should produce an integer. If count-form is
zero or negative, the body is not executed. dotimes then executes the body once
for each integer from 0 up to but not including the value of count-form with var
bound to current integer value. If result-form is presented, then dotimes
returns result of result form, otherwise it returns nil.

6.4 dolist
==========
Macro: (dolist (var list-form [result-form]) body)

Parameters: var - symbol.
            list-form - form.
            result-form - form.
            body - form+.

Dolist iterates over the elements of a list.

Dolist evaluates list-form, which should produce a list. It then evaluates the
body in implicit progn once for each element in the list, with var bound to the
element. If result-form is presented, then dolist returns result of result form,
otherwise it returns nil.



===============================================================================
7 Structures
===============================================================================
7.1 defstruct
=============
Macro 'defstruct' defines structure with named slots. Underlying type for
structure is vector.

Syntax:
  (defstruct struct-descr [doc] {slot-descr}+) ==> struct-name

  struct-descr ::= struct-name | (struct-name struct-options)
  struct-name ::= symbol, name of struct
  struct-options ::= export-option
  export-option ::= :export | (:export bool)
  doc ::= string
  slot-descr ::= slot-name | (slot-name init-form)
  slot-name ::= symbol, name of slot

'Export-option' defines if structure functions and macros should be exported. By
default they are not exported.

'Defstruct' generates miscellaneous named functional objects for constructing
structure and operate with its slots. Functional object may be lambda or macro.

Constructor:
  (struct-name-create &key {slot-description}*) ==> struct-name
Constructs structure and initializes it. Returns freshly constructed object.

Structure predicate:
  (struct-namep x) ==> bool
Returns true if x is object of structure 'name'.

Slot readers:
  (struct-name-slot-name x) ==> object
Returns value of 'slot-name'. 'x' must be object of type 'struct-name'.

Slot writers:
  (struct-name-slot-name-set x val) ==> val
Assigns slot to new value. 'x' must be object of type 'struct-name'.

7.2 undefstruct
===============
Function: (undefstruct sym) ==> bool

Parameters: sym - symbol

Undefines structure, previosly defined with defstruct. Does nothing, if
structure is not defined. Returns true, if structure was undefined. Otherwise,
returns nil.

7.3 struct-slots
================
Function: (struct-slots sym) ==> list

Parameters: sym - symbol

Returns list of structure slots, previosly defined with defstruct. If structure
is not defined, then returns nil.



===============================================================================
8 Numeric functions
===============================================================================
8.1 +
=====
Function: (+ &rest args) ==> number

Parameters: args - numbers

Returns sum of numbers. If non arguments are specified, then 0 is returned.

8.2 -
=====
Function: (- minuend &rest subtrahends) ==> number

Parameters: minuend - number
            subtrahends - numbers

Performs arithmetic subtraction and negation. If only one number is supplied,
the negation of that number is returned. If more than one argument is given, it
subtracts all of the subtrahends from the minuend and returns the result.

8.3 *
=====
Function: (* &rest args) ==> number

Parameters: args - numbers

Returns the product of numbers. If no numbers are supplied, 1 is returned.

8.4 /
=====
Function: (/ numerator &rest denominators) ==> float

Parameters: numerator - number
            denominators - numbers

Performs floating point division of numerator by denominators or reciprocation
of numerator, if no denominators are supplied. Always returns floating point
number.

8.5 div
========
Function: (div numerator &rest denominators) ==> integer

Parameters: numerator - integer
            denominators - integers

Performs integer division of numerator by denominators. Each division is
truncated, if numerator is not divisible by current denominator.

8.6 rem
========
Function: (rem number divisor) ==> integer

Parameters: number - integer
            divisor - integer

Calculates remainder of integer division of number by divisor.

8.7 zerop
==========
Function: (zerop x) ==> bool

Parameters: x - number

Returns true, if x is equal to 0, otherwise, nil.

8.8 abs
========
Function: (abs x) ==> number

Parameters: x - number

Returns the absolute value of the number x.

8.9 band
=========
Function: (band &rest args) ==> integer

Parameters: args - integers.

Performs bitwise 'and' operation of integers.

8.10 bor
========
Function: (bor &rest args) ==> integer

Parameters: args - integers.

Performs bitwise 'or' operation of integers.

8.11 bxor
=========
Function: (bxor &rest args) ==> integer

Parameters: args - integers.

Performs bitwise 'xor' operation of integers.

8.12 bnot
=========
Function: (bnot x) ==> integer

Parameters: x - integer.

Performs bitwise 'not' operation of integer.

8.13 bshl
=========
Function: (bshl x bits) ==> integer

Parameters: x - integer.
            bits - fixnum

Shifts integer left on given number of 'bits'.

8.14 bshr
=========
Function: (bshr x bits) ==> integer

Parameters: x - integer.
            bits - fixnum

Shifts integer right on given number of 'bits'.

8.15 minusp
===========
Function: (minusp x) ==> bool

Parameters: x - number.

Returns true if number is negative; otherwise returns false.

8.16 plusp
===========
Function: (plusp x) ==> bool

Parameters: x - number.

Returns true if number is positive; otherwise returns false.

8.17 fixnump
============
Function: (fixnump x) ==> bool

Parameters: x - object.

Returns true if object is fixnum integer; otherwise returns false.

8.18 bigintp
============
Function: (bigintp x) ==> bool

Parameters: x - object.

Returns true if object is big integer; otherwise returns false.

8.19 integerp
=============
Function: (integerp x) ==> bool

Parameters: x - object.

Returns true if object is integer; otherwise returns false.

8.20 doublep
============
Function: (doublep x) ==> bool

Parameters: x - object.

Returns true if object is double floating point number; otherwise returns false.

8.21 numberp
============
Function: (numberp x) ==> bool

Parameters: x - object.

Returns true if object is number; otherwise returns false.

8.22 <
======
Function: (< num &rest other) ==> bool

Parameters: num - number.
            other - numbers

Returns true if each following number is less then previos one; otherwise
returns false. Also returns true, if only single number is given.

8.23 <=
=======
Function: (<= num &rest other) ==> bool

Parameters: num - number.
            other - numbers

Returns true if each following number is less or equal to previos one; otherwise
returns false. Also returns true, if only single number is given.

8.24 >
======
Function: (> num &rest other) ==> bool

Parameters: num - number.
            other - numbers

Returns true if each following number is greater then previos one; otherwise
returns false. Also returns true, if only single number is given.

8.25 >=
=======
Function: (>= num &rest other) ==> bool

Parameters: num - number.
            other - numbers

Returns true if each following number is greater or equal to previos one;
otherwise returns false. Also returns true, if only single number is given.

8.26 =
======
Function: (= num &rest other) ==> bool

Parameters: num - number.
            other - numbers

Returns true if all numbers are equal; otherwise returns false. Also returns
true, if only single number is given.

8.27 /=
=======
Function: (/= num &rest other) ==> bool

Parameters: num - number.
            other - numbers

Returns true if all numbers are not equal; otherwise returns false. Also returns
true, if only single number is given.

8.28 1+
=======
Function: (1+ num) ==> number

Parameters: num - number.

Returns number, which is one more than argument.

8.29 1-
=======
Function: (1- num) ==> number

Parameters: num - number.

Returns number, which is one less than argument.

8.30 evenp
==========
Function: (evenp x) ==> bool

Parameters: x - integer

Returns true, if number is even (divisible by two); otherwise, returns false.

8.31 oddp
=========
Function: (oddp x) ==> bool

Parameters: x - integer

Returns true, if number is odd (not divisible by two); otherwise, returns false.

8.32 finitep
============
Function: (finitep x) ==> bool

Parameters: x - number

Returns true, if number is finite and is number.

8.33 infinitep
==============
Function: (infinitep x) ==> bool

Parameters: x - number

Returns true, if number is infinite.

8.34 nanp
==============
Function: (nanp x) ==> bool

Parameters: x - number

Returns true, if number is not a number.



===============================================================================
9 Mathematical Functions
===============================================================================
Mathematical functions are reside in 'm' package.

9.1 Mathematical Constants
==========================

9.1.1 m:e
=========
Constant: m:e

The base of natural logarithms.

9.1.2 m:log2e
=============
Constant: m:log2e

The logarithm to base 2 of m:e.

9.1.3 m:log10e
==============
Constant: m:log10e

The logarithm to base 10 of m:e.

9.1.4 m:ln2
===========
Constant m:ln2

The natural logarithm of 2.

9.1.5 m:ln10
============
Constant m:ln10

The natural logarithm of 10.

9.1.5 m:pi
==========
Constatnt: m:pi

Pi, the ratio of a circle's circumference to its diameter.

9.1.6 m:pi/2
============
Constatnt: m:pi/2

Pi divided by two.

9.1.7 m:pi/4
============
Constatnt: m:pi/4

Pi divided by four.

9.1.8 m:1/pi
============
Constatnt: m:1/pi

The reciprocal of pi (1/pi).

9.1.9 m:2/pi
============
Constatnt: m:2/pi

Two times the reciprocal of pi (2/pi).

9.1.10 m:2/sqrt_pi
================
Constatnt: m:2/sqrt_pi

Two times the reciprocal of the square root of pi (2/sqrt(pi)).

9.1.11 m:sqrt2
==============
Constatnt: m:sqrt2

The square root of two.

9.1.12 m:sqrt1/2
================
Constatnt: m:sqrt1/2

The reciprocal of the square root of two (also the square root of 1/2).

9.2 m:exp
=========
Function: (m:exp x) ==> double

Parameters: x - number

Returns e raised to the power 'x', where e is the base of the natural logarithms.

9.3 m:pow
=========
Function: (m:pow base power) ==> double

Parameters: base - number
            power - number

Raises 'base' into 'power' power.

9.4 m:acos
==========
Function: (m:acos x) ==> double

Parameters: x - number

Returns the arc cosine of 'x' in radians; the return value is in the range [0, pi].

9.5 m:acosh
===========
Function: (m:acosh x) ==> double

Parameters: x - number

Returns the inverse hyperbolic cosine of x.

9.6 m:asin
==========
Function: (m:asin x) ==> double

Parameters: x - number

Returns the principal value of the arc sine of 'x' in radians; the return value is
in the range [-pi/2, pi/2].

9.7 m:asinh
===========
Function: (m:asinh x) ==> double

Parameters: x - number

Returns the inverse hyperbolic sine of 'x'.

9.8 m:atan
==========
Function: (m:atan x) ==> double

Parameters: x - number

Returns the principal value of the arc tangent of 'x' in radians; the return value is
in the range [-pi/2, pi/2].

9.9 m:atan2
==========
Function: (m:atan2 y x) ==> double

Parameters: y - number
            x - number

Returns the principal value of the arc tangent of y/x in radians; the return
value is in the range [-pi, pi].

9.10 m:atanh
============
Function: (m:atanh x) ==> double

Parameters: x - number

Return the inverse hyperbolic tangent of 'x'.

9.11 m:cbrt
===========
Function: (m:cbrt x) ==> double

Parameters: x - number

Returns the cube root of x.

9.12 m:ceil
===========
Function: (m:ceil x) ==> number

Parameters: x - number

Returns the smallest integral value that is not less than x. For example,
(ceil 0.5) is 1.0, and (ceil -0.5) is 0.0. If x is integral, +0, -0, NaN, or
infinite, x itself is returned.

9.13 m:cos
==========
Function: (m:cos x) ==> double

Parameters: x - number

Returns the cosine of x, where x is given in radians.

9.14 m:cosh
===========
Function: (m:cosh x) ==> double

Parameters: x - number

Returns the hyperbolic cosine of x, which is defined mathematically as:
        cosh(x) = (exp(x) + exp(-x)) / 2

9.15 m:erf
==========
Function: (m:erf x) ==> double

Parameters: x - number

Returns the error function of x, defined as:
        erf(x) = 2/sqrt(pi)* integral from 0 to x of exp(-t*t) dt
Returned value is in range [-1, 1].

9.16 m:erfc
===========
Function: (m:erfc x) ==> double

Parameters: x - number

Returns the complementary error function of x, that is, 1.0 - erf(x). Returned
value is in range [0, 2].

9.17 m:exp2
===========
Function: (m:exp2 x) ==> double

Parameters: x - number

Returns the value of 2 raised to the power of 'x'.

9.18 m:expm1
============
Function: (m:expm1 x) ==> double

Parameters: x - number

Returns a value equivalent to exp(x) - 1. It is computed in a way that is
accurate even if the value of x is near zero - a case where exp(x) - 1 would be
inaccurate due to subtraction of two numbers that are nearly equal.

9.19 m:floor
============
Function: (m:floor x) ==> number

Parameters: x - number

Returns the largest integral value that is not greater than x. For example,
floor(0.5) is 0.0, and floor(-0.5) is -1.0. If x is integral, +0, -0, NaN, or an
infinity, x itself is returned.

9.20 m:log
==========
Function: (m:log x) ==> double

Parameters: x - number

Returns the natural logarithm of x.

9.21 m:log10
============
Function: (m:log10 x) ==> double

Parameters: x - number

Returns the base 10 logarithm of x.

9.22 m:log2
===========
Function: (m:log2 x) ==> double

Parameters: x - number

Returns the base 2 logarithm of x.

9.23 m:round
============
Function: (m:round x) ==> number

Parameters: x - number

Round x to the nearest integer. For example, round(0.5) is 1.0, and round(-0.5)
is -1.0. If x is integral, +0, -0, NaN,  or infinite, x itself is returned.

9.24 m:sin
==========
Function: (m:sin x) ==> double

Parameters: x - number

Returns the sine of x, where x is given in radians.

9.25 m:sinh
===========
Function: (m:sinh x) ==> double

Parameters: x - number

Returns the hyperbolic sine of x, which is defined mathematically as:
        sinh(x) = (exp(x) - exp(-x)) / 2

9.26 m:sqrt
===========
Function: (m:sqrt x) ==> double

Parameters: x - number

Returns the nonnegative square root of x.

9.27 m:tan
==========
Function: (m:tan x) ==> double

Parameters: x - number

Returns the tangent of x, where x is given in radians.

9.28 m:tanh
===========
Function: (m:tanh x) ==> double

Parameters: x - number

Returns the hyperbolic tangent of x, which is defined mathematically as:
        tanh(x) = sinh(x) / cosh(x)

9.29 m:trunc
============
Function: (m:trunc x) ==> number

Parameters: x - number

Round x to the nearest integer not larger in absolute value. If x is integral,
infinite, or NaN, x itself is returned.



===============================================================================
10 Symbols functions
===============================================================================
10.1 symbolp
============
Function: (symbolp x) ==> bool

Parameters: x - object

Returns true if x is symbol; otherwise, returns false.

10.2 keywordp
=============
Function: (keywordp x) ==> bool

Parameters: x - object

Returns true if x is keyword symbol; otherwise, returns false.

10.3 symbol-create
==================
Function: (symbol-create name) ==> symbol

Parameters: name - string. Name of symbol. Name-slot of symbol is set to copy of
            name.

Creates and returns a fresh, uninterned symbol.

10.4 symbol-name
=================
Function: (symbol-name x) ==> string

Parameters: x - symbol

Returns name slot of symbol object.

10.5 symbol-boundp
==================
Function: (symbol-boundp x) ==> bool

Parameters: x - symbol

Returns true, if dynamic variable x is bound.

10.6 symbol-fboundp
===================
Function: (symbol-fboundp x) ==> bool

Parameters: x - symbol

Returns true, if symbol function slot is bound.

10.7 dynamic
============
Function: (dynamic sym) ==> object

Parameters: sym - symbol

Returns value of global dynamic variable. Variable must be defined with 'defvar'
or 'defparameter' macros or 'dynamic-let' special form.

10.8 set-dynamic
================
Function: (set-dynamic sym val) ==> val

Parameters: sym - symbol
            val - object

Sets value of global dynamic variable. Variable must be defined with 'defvar' or
'defparameter' macros or 'dynamic-let' special form.

10.9 symbol-function
=====================
Function: (symbol-function x) ==> lambda or macro

Parameters: x - symbol

Returns function slot of symbol. Function slot must be bound.

10.10 symbol-set-prop
=====================
Function: (symbol-set-prop sym key val) ==> sym

Parameters: sym - symbol
            key - object
            val - object

Updates symbol's property in plist slot of symbol object. If key is not exists
new key-value pair is added to properties list. Keys are matched using 'eq'
function.

10.11 symbol-get-prop
=====================
Function: (symbol-get-prop sym key &optional default-val) ==> object

Parameters: sym - symbol
            key - object
            default-val - object

Searches symbol's plist slot for given key. If key is not found, then supplied
default-val is returned. Keys are matched using 'eq' function.

10.12 symbol-rm-prop
====================
Function: (symbol-rm-prop sym key) ==> sym

Parameters: sym - symbol
            key - object

Removes key, if presented, from symbol's plist slot. Keys are matched using
'eq' function.

10.13 symbol-package
====================
Function: (symbol-package sym) ==> string or nil

Parameters: sym - symbol

Returns name of package, in which symbol is interned. If symbol is uninterned
then nil is returned.

10.14 define-symbol-macro
=========================
Macro: (define-symbol-macro sym expansion) ==> sym

Parameters: sym - symbol
            expansion - form

Defines global symbol macro - each reference to 'sym' as to dynamic variable is
expanded to 'expansion' form and then evaluated.

10.15 symbol-macro
==================
Function: (symbol-macro sym &optional not-found) ==> form

Parameters: sym - symbol
            not-found - form. Value returned in case when symbol does not have
              macro bound with define-symbol-macro macro.

Returns macro bound to symbol with define-symbol-macro macro.

10.16 undefine-symbol-macro
===========================
Function: (undefine-symbol-macro sym) ==> bool

Parameters: sym - symbol

Unbinds macro bound to symbol with define-symbol-macro macro. Returns true if
macro was really undefined. Otherwise, returns nil.

10.17 gensym
============
Function: (gensym &optional (prefix "g")) ==> symbol

Parameters: prefix - string

Creates fresh uninterned symbol like 'symbol-create' function. The difference is
how symbol name is produced: gensym generates symbol name in form '#:prefixN',
where 'prefix' is parameter and N is current value of gensym's internal
counter. Value of counter is incremented on each call of gensym.



===============================================================================
11 Packages Functions.
===============================================================================
There is "kl" package: where all basic K-Lisp functions are defined. Public
symbols from that package are always accessible, without "kl:" prefix.

There is "keyword" package. Symbols in that package are constants and evaluated
to itself. Symbols in that package may be referenced using super short natation
with empty package name (see bellow).

Symbols may be written using short or full syntax. Full syntax is
"package:symbol" for exported symbols and "package::symbol" for private symbols.
And short syntax is "symbol".

Symbols with name in form "#:name" are always produce fresh uninterned symbols.

Current active package is stored in *package* global variable.

Reader's symbol resolution algorithm, when it encounters string representation
of symbol:
  1. If symbol has package prefix:
       a. If prefix is "#", create new uninterned symbol.
       b. If prefix is empty "", assume that package is keyword package.
       c. Look symbol in corresponding package. If symbol is found and it is not
          exported, but exported natation with single colon ":" was used, like
          "package:name", then symbol is marked as exported. If symbol was
          exported, but private natation with double colon "::" was used, like
          "package::name", then symbol remains exported.
       d. If symbol is not found, then intern symbol into package and assign
          exporting attribute according to ":" or "::" syntax.
  2. Look symbol in current package. If symbol is found, then it is returned.
  3. Look symbol in exported symbols of "kl" package. If symbol is found, then
     it is returned.
  4. Intern unexported symbol in current package and return it.

Unused symbols are automatically collected by garbage collector. So symbol with
same name may be referenced with ":" and "::" without error, if it is unused and
was collected between references. Symbols naming global dynamic variables and
functions are protected from garbage collecting untill variables and functions
are bound.

Empty packages are automatically collected by garbage collector.

11.1 *package*
==============
Variable: *package*

Holds current active package.

11.2 in-package
===============
Macro: (in-package name) ==> package

Parameters: name - symbol

Causes the the package named by 'name' to become the current package - that is,
the value of '*package*' global variable. If no such package already exists,
then package is created automatically.

11.3 intern
===========
Function: (intern name &key (package *package*) exported) ==> symbol

Parameters: name - string
            package - symbol or string or package
            exported - bool

Function intern enters a symbol named 'name' into package. If package is
ommited, then symbol interned into current package. If symbol with such name is
already exist in package, the this symbol is returned. If 'exported' is true,
then new symbol is exported. 'Exported' does not affect symbols, already
presented in package.

11.4 unintern
============
Function: (unintern sym) ==> sym

Parameters: sym - symbol

Removes symbol from package, to which symbol relates. Returns same, but
uninterned symbol.

11.5 internedp
==============
Function: (internedp x) ==> bool

Parameters: x - symbol.

Returns true if symbol is interned.

11.6 export
===========
Function: (export sym) ==> sym

Parameters: sym - symbol

Exports symbol from it's package.

11.7 unexport
=============
Function: (unexport sym) ==> sym

Parameters: sym - symbol

Removes symbol from exported list of package.

11.8 exportedp
==============
Function: (exportedp sym) ==> bool

Parameters: sym - symbol

Returns true, if symbol is exported from package.

11.9 find-create-package
========================
Function: (find-create-package name) ==> package

Parameters: name - string or symbol.

Searches for package with given name. If package does not exit, it is created.

11.10 package-name
==================
Function: (package-name package) ==> string

Parameters: package - package

Returns name of package.

11.11 do-packages
=================
Macro: (do-packages (var [result]) statement+)

Parameters: var - symbol
            result - form, default nil
            statement - form

Iterates over all packages. For each package the 'var' is bound to the package,
and the statements in the body are executed. When all the package have been
processed, 'result' form is evaluated and returned as the value of the macro.

11.12 do-symbols
================
Macro: (do-symbols (var [package [result]]) statement+)

Parameters: var - symbol
            package - symbol or string or package, default is current package
            result - form, default nil
            statement - form

Iterates over all symbols in package. For each symbol the 'var' is bound to the symbol,
and the statements in the body are executed. When all the symbols have been
processed, 'result' form is evaluated and returned as the value of the macro.

11.13 do-all-symbols
====================
Macro: (do-all-symbols (var [result]) statement+)

Parameters: var - symbol
            result - form, default nil
            statement - form

Iterates over all symbols in all package. For each symbol the 'var' is bound to
the symbol, and the statements in the body are executed. When all the symbols
have been processed, 'result' form is evaluated and returned as the value of the
macro.



===============================================================================
12 Characters Functions
===============================================================================
12.1 charp
==========
Function: (charp x) ==> bool

Parameters: x - object

Returns true, if x is character.

12.2 char-to-int
================
Function: (char-to-int x) ==> integer

Parameters: x - char

Converts character to integer.

12.3 char-from-int
==================
Function: (char-from-int x) ==> character

Parameters: x - integer

Converts integer to character. Integer must be valid Unicode character code.

12.4 char-alphap
================
Function: (char-alphap x) ==> bool

Parameters: x - char

Returns true if x is an alphabetic character.

12.5 char-alphanumericp
=======================
Function: (char-alphanumericp x) ==> bool

Parameters: x - char

Returns true if x is an alphanumeric character.

12.6 char-controlp
==================
Function: (char-controlp x) ==> bool

Parameters: x - char

Returns true if x is a control character.

12.7 char-digitp
================
Function: (char-digitp x) ==> bool

Parameters: x - char

Returns true if x is a digit character.

12.8 char-graphp
================
Function: (char-graphp x) ==> bool

Parameters: x - char

Determines whether a character is printable and not a space (returns nil for
control characters, format characters, and spaces). char-printp is similar, but
returns true for spaces.

12.9 char-lowerp
================
Function: (char-lowerp x) ==> bool

Parameters: x - char

Determines whether a character is a lowercase letter.

12.10 char-printp
=================
Function: (char-printp x) ==> bool

Parameters: x - char

Determines whether a character is printable. Unlike char-graphp, returns true
for spaces.

12.11 char-punctp
=================
Function: (char-punctp x) ==> bool

Parameters: x - char

Determines whether a character is punctuation or a symbol.

12.12 char-spacep
=================
Function: (char-spacep x) ==> bool

Parameters: x - char

Determines whether a character is a space, tab, or line separator (newline,
carriage return, etc.).

12.13 char-upperp
=================
Function: (char-upperp x) ==> bool

Parameters: x - char

Determines if a character is uppercase.

12.14 char-xdigitp
==================
Function: (char-xdigitp x) ==> bool

Parameters: x - char

Determines if a character is a hexidecimal digit.

12.15 char-to-lower
==================
Function: (char-to-lower x) ==> char

Parameters: x - char

Converts a character to lower case.

12.16 char-to-upper
===================
Function: (char-to-upper x) ==> char

Parameters: x - char

Converts a character to uppercase.



===============================================================================
13 String Functions
===============================================================================
13.1 stringp
============
Function: (stringp x) ==> bool

Parameters: x - object

Returns true if object is string.

13.2 string
===========
Function: (string &rest args) ==> string

Parameters: args - one of: character, string or binary. Binary represents
              multibyte string, encoded according current thread's locale. It is
              converted to Unicode before inserting in new string.

Creates new string object and populates it with given arguments.

13.3 string-create
==================
Function: (string-create size &key (init-element #" ") max-capacity) ==> string

Parameters: size - non negative fixnum
            init-element - character
            max-capacity - non negative fixnum

Creates new string of given initial size and maximal capacity and fills it with
given initial element.

13.4 string-length
==================
Function: (string-length seq) ==> fixnum

Parameters: seq - string

Returns length of string.

13.5 string-ref
===============
Function: (string-ref seq pos) ==> char

Parameters: seq - string
            pos - non negative fixnum

Returns element at 'pos' position of string.

13.6 string-set
===============
Function: (string-set seq pos val) ==> val

Parameters: seq - string
            pos - non negative fixnum
            val - char

Sets value of character at 'pos' position of string.

13.7 string-append-char
=======================
Function: (string-append-char seq x) ==> seq

Parameters: seq - string
            x - character

Appends character to end of string.

13.8 string-append-binary
=========================
Function: (string-append-binary dest src &key (src-offset 0) src-len) ==> dest

Parameters: dest - destination string
            src - source binary. Binary must be multibyte string, encoded in
              current thread's locale.
            src-offset - fixnum. Offset within source.
            src-len - number of elements in source to add to destination. If nil
              is passed, than whole source, starting from src-offset is added.

Converts multibyte string to Unicode and appends it to end of string.

13.9 string-append-binary-utf8
==============================
Function: (string-append-binary-utf8 dest src &key (src-offset 0) src-len) ==> dest

Parameters: dest - destination string
            src - source binary. Binary must be multibyte string, encoded in UTF-8.
            src-offset - fixnum. Offset within source.
            src-len - number of elements in source to add to destination. If nil
              is passed, than whole source, starting from src-offset is added.

Converts multibyte string to Unicode and appends it to end of string.

13.10 string-append-string
=========================
Function: (string-append-string dest src &key (src-offset 0) src-len) ==> dest

Parameters: dest - destination string
            src - source string
            src-offset - fixnum. Offset within source.
            src-len - number of elements in source to add to destination. If nil
              is passed, than whole source, starting from src-offset is added.

Appends string to end of string.

13.11 string-incr-capacity
==========================
Function: (string-incr-capacity seq delta) ==> seq

Parameters: seq - string
            delta - capacity delta, non negative fixnum

Ensures that string has enough capacity to append 'delta' characters without
storage reallocations.

13.12 string-clear
==================
Function: (string-clear seq) ==> seq

Parameters: seq - string

Removes all characters from string.

13.13 string-remove
===================
Function: (string-remove seq start &optional count) ==> seq

Parameters: seq - string
            start - start position, non negative fixnum.
            count - number of elements to remove, non negative fixnum. If count
            is nil sequence is truncated from 'start' position.

Removes 'count' characters in string starting from 'start' position.

13.14 string-insert-char
========================
Function: (string-insert-char seq pos x) ==> seq

Parameters: seq - string
            pos - position to insert, non negative fixnum.
            x - character

Inserts character into string at given position. String is modified.

13.15 string-insert-binary
==========================
Function: (string-insert-binary dest dest-pos src &key (src-offset 0) src-len) ==> dest

Parameters: dest - destination string
            dest-pos - position to insert, non negative fixnum.
            src - source binary. Binary must be multibyte string, encoded in
              current thread's locale.
            src-offset - fixnum. Offset within source.
            src-len - number of elements in source to add to destination. If nil
              is passed, than whole source, starting from src-offset is added.

Converts multibyte string to Unicode and inserts it into string at given
position. String is modified.

13.16 string-insert-binary-utf8
===============================
Function: (string-insert-binary-utf8 dest dest-pos src &key (src-offset 0) src-len) ==> dest

Parameters: dest - destination string
            dest-pos - position to insert, non negative fixnum.
            src - source binary. Binary must be multibyte string, encoded in UTF-8.
            src-offset - fixnum. Offset within source.
            src-len - number of elements in source to add to destination. If nil
              is passed, than whole source, starting from src-offset is added.

Converts multibyte string to Unicode and inserts it into string at given
position. String is modified.

13.17 string-insert-string
==========================
Function: (string-insert-string dest dest-pos src &key (src-offset 0) src-len) ==> dest

Parameters: dest - destination string
            dest-pos - position to insert, non negative fixnum.
            src - source string.
            src-offset - fixnum. Offset within source.
            src-len - number of elements in source to add to destination. If nil
              is passed, than whole source, starting from src-offset is added.

Inserts string into another string at given position. String is modified.

13.18 string-reverse
====================
Function: (string-reverse seq &key (start 0) len) ==> seq

Parameters: seq - string
            start - non negative fixnum. Start position to reverse
            len - non negative fixnum. Length of reversed sequence within
              original one.

Reverses string in place.

13.19 string-set-max-capacity
=============================
Function: (string-set-max-capacity seq capacity) ==> seq

Parameters: seq - string
            capacity - non negative fixnum. Must be greater or equal current
              string length.

Limits maximal capacity of string.

13.20 string-concat
===================
Function: (string-concat seq &rest args) ==> seq

Parameters: seq - string
            args - one of: character, string or binary, representing multibyte
              string, encoded in current thread's locale

Appends all arguments to string.

13.21 string-compare
====================
Function: (string-compare s1 s2) ==> fixnum

Parameters: s1 - string
            s2 - string

Compares two strings. It returns an fixnum less than, equal to, or greater than
zero if s1 is found, respectively, to be less than, to match, or be greater than
s2.

13.22 string-icompare
=====================
Function: (string-icompare s1 s2) ==> fixnum

Parameters: s1 - string
            s2 - string

Compares two strings, ignoring case. It returns an fixnum less than, equal to,
or greater than zero if s1 is found, respectively, to be less than, to match, or
be greater than s2.

13.23 string-find-char
======================
Function: (string-find-char seq chr &optional (start 0)) ==> fixnum or nil

Parameters: seq - string
            chr - character
            start - fixnum

Searches string for character from 'start' position. Returns character position
or nil, if character is not found.

13.24 string-find-string
========================
Function: (string-find-string seq str &optional (start 0)) ==> fixnum or nil

Parameters: seq - string
            str - string to find
            start - fixnum

Searches string for substring from 'start' position. Returns substring position or
nil, if substring is not found.

13.25 substring
===============
Function: (substring seq &key (start 0) length dest) ==> string or dest

Parameters: seq - string
            start - fixnum
            length - fixnum. If not specified, then substring extracted upto end
              of string.
            dest - string. If specified, then substring is added to end of
              'dest' parameter.

Extracts substring from string. Returns new string, if 'dest' parameter is not
specified. Otherwise, 'dest' parameter is returned.

13.26 string-starts
===================
Function: (string-starts str prefix) ==> boolean

Parameters: str - string
            prefix - string

Checks if string 'str' starts with given prefix.



===============================================================================
14 Binary Functions
===============================================================================
14.1 binaryp
============
Function: (binaryp x) ==> bool

Parameters: x - object

Returns true if object is binary.

14.2 binary
===========
Function: (binary &rest args) ==> binary

Parameters: args - one of: integer in range 0-255, character, string or binary.

Creates new binary object and populates it with given arguments.

14.3 binary-create
==================
Function: (binary-create size &key (init-element 0) max-capacity) ==> binary

Parameters: size - non negative fixnum
            init-element - integer in range 0-255
            max-capacity - non negative fixnum

Creates new binary of given initial size and maximal capacity and fills it with
given initial element.

14.4 binary-length
==================
Function: (binary-length seq) ==> fixnum

Parameters: seq - binary

Returns length of binary.

14.5 binary-ref
===============
Function: (binary-ref seq pos) ==> byte

Parameters: seq - binary
            pos - non negative fixnum

Returns integer in range 0-255 at 'pos' position of binary.

14.6 binary-set
===============
Function: (binary-set seq pos val) ==> val

Parameters: seq - binary
            pos - non negative fixnum
            val - integer in range 0-255

Sets value of element at position 'pos' of binary.

14.7 binary-append-char
=======================
Function: (binary-append-char seq x) ==> seq

Parameters: seq - binary
            x - integer in range 0-255.

Appends byte to end of binary.

14.8 binary-append-binary
=========================
Function: (binary-append-binary dest src &key (src-offset 0) src-len) ==> dest

Parameters: dest - destinationbinary
            src - source binary.
            src-offset - fixnum. Offset within source.
            src-len - number of elements in source to add to destination. If nil
              is passed, than whole source, starting from src-offset is added.

Appends binary object to end of binary.

14.9 binary-append-char
=======================
Function: (binary-append-char seq x) ==> seq

Parameters: seq - binary
            x - character. Character is converted to multibyte character, using
              current thread's locale.

Appends character to end of binary.

14.10 binary-append-char-utf8
=============================
Function: (binary-append-char-utf8 seq x) ==> seq

Parameters: seq - binary
            x - character. Character is converted to UTF-8 encoded character.

Appends character to end of binary.

14.11 binary-append-string
==========================
Function: (binary-append-string dest src &key (src-offset 0) src-len) ==> dest

Parameters: dest - destination binary
            src - source string. String is converted to multibyte string, using
              current thread's locale.
            src-offset - fixnum. Offset within source.
            src-len - number of elements in source to add to destination. If nil
              is passed, than whole source, starting from src-offset is added.

Appends string to end of binary.

14.12 binary-append-string-utf8
===============================
Function: (binary-append-string-utf8 dest src &key (src-offset 0) src-len) ==> dest

Parameters: dest - destination binary
            src - source string. String is converted to UTF-8 string.
            src-offset - fixnum. Offset within source.
            src-len - number of elements in source to add to destination. If nil
              is passed, than whole source, starting from src-offset is added.

Appends string to end of binary.

14.13 binary-incr-capacity
==========================
Function: (binary-incr-capacity seq delta) ==> seq

Parameters: seq - binary
            delta - capacity delta, non negative fixnum

Ensures that 'delta' bytes may be added to binary without storage reallocations.

14.14 binary-clear
==================
Function: (binary-clear seq) ==> seq

Parameters: seq - binary

Erases all elements in binary.

14.15 binary-remove
===================
Function: (binary-remove seq start &optional count) ==> seq

Parameters: seq - binary
            start - start position, non negative fixnum.
            count - number of elements to remove, non negative fixnum. If count
              is nil sequence is truncated from 'start' position.

Removes 'count' elements in binary starting from 'start' position.

14.16 binary-insert-byte
========================
Function: (binary-insert-byte seq pos x) ==> seq

Parameters: seq - binary
            pos - position to insert, non negative fixnum.
            x - integer in range 0-255.

Inserts byte into binary at given position.

14.17 binary-insert-binary
==========================
Function: (binary-insert-binary dest dest-pos src &key (src-offset 0) src-len) ==> dest

Parameters: dest - destination binary
            dest-pos - position to insert, non negative fixnum.
            src - source binary.
            src-offset - fixnum. Offset within source.
            src-len - number of elements in source to add to destination. If nil
              is passed, than whole source, starting from src-offset is added.

Inserts binary object into another binary at given position.

14.18 binary-insert-char
========================
Function: (binary-insert-char seq pos x) ==> seq

Parameters: seq - binary
            pos - position to insert, non negative fixnum.
            x - character. Character is converted to multibyte character, using
              current thread's locale.

Inserts character into binary at given position.

14.19 binary-insert-char-utf8
=============================
Function: (binary-insert-char-utf8 seq pos x) ==> seq

Parameters: seq - binary
            pos - position to insert, non negative fixnum.
            x - character. Character is converted UTF-8.

Inserts character into binary at given position.

14.20 binary-insert-string
==========================
Function: (binary-insert-string dest dest-pos src &key (src-offset 0) src-len) ==> dest

Parameters: dest - destination binary
            dest-pos - destination position to insert, non negative fixnum.
            src - source string. String is converted to multibyte string, using
              current thread's locale.
            src-offset - fixnum. Offset within source.
            src-len - number of elements in source to add to destination. If nil
              is passed, than whole source, starting from src-offset is added.

Inserts string into binary at given position.

14.21 binary-insert-string-utf8
===============================
Function: (binary-insert-string-utf8 dest dest-pos src &key (src-offset 0) src-len) ==> dest

Parameters: dest - destination binary
            dest-pos - destination position to insert, non negative fixnum.
            src - source string. String is converted to UTF-8.
            src-offset - fixnum. Offset within source.
            src-len - number of elements in source to add to destination. If nil
              is passed, than whole source, starting from src-offset is added.

Inserts string into binary at given position.

14.22 binary-reverse
====================
Function: (binary-reverse seq &key (start 0) len) ==> seq

Parameters: seq - binary
            start - non negative fixnum. Start position to reverse
            len - non negative fixnum. Length of reversed sequence within
              original one.

Reverses binary in place.

14.23 binary-set-max-capacity
=============================
Function: (binary-set-max-capacity seq capacity) ==> seq

Parameters: seq - binary
            capacity - non negative fixnum. Must be greater or equal current
            sequence length.

Limits maximal capacity of binary object to given value.

14.24 binary-concat
===================
Function: (binary-concat seq &rest args) ==> seq

Parameters: seq - binary
            args - one of: integer in range 0-255, character, string or binary.

Appends all arguments to binary.

14.25 binary-find-byte
======================
Function: (binary-find-byte seq byte &optional (start 0)) ==> fixnum or nil

Parameters: seq - binary
            byte - integer in range 0-255
            start - fixnum

Searches binary for byte from 'start' position. Return byte position or nil, if
byte is not found.



===============================================================================
15 Binary Encoding/Decoding Functions
===============================================================================
15.1 Integers encoding decoding
===============================
Functions: (binary-append-int8 seq x) ==> seq
           (binary-ref-int8 seq offset) ==> integer
           (binary-append-uint8 seq x) ==> seq
           (binary-ref-uint8 seq offset) ==> integer
           (binary-set-int8 seq offset x) ==> seq
           (binary-set-uint8 seq offset x) ==> seq

           (binary-append-int16-le seq x) ==> seq
           (binary-append-int16-be seq x) ==> seq
           (binary-append-int16-me seq x) ==> seq
           (binary-ref-int16-le seq offset) ==> integer
           (binary-ref-int16-be seq offset) ==> integer
           (binary-ref-int16-me seq offset) ==> integer
           (binary-set-int16-le seq offset x) ==> seq
           (binary-set-int16-be seq offset x) ==> seq
           (binary-set-int16-me seq offset x) ==> seq

           (binary-append-uint16-le seq x) ==> seq
           (binary-append-uint16-be seq x) ==> seq
           (binary-append-uint16-me seq x) ==> seq
           (binary-ref-uint16-le seq offset) ==> integer
           (binary-ref-uint16-be seq offset) ==> integer
           (binary-ref-uint16-me seq offset) ==> integer
           (binary-set-uint16-le seq offset x) ==> seq
           (binary-set-uint16-be seq offset x) ==> seq
           (binary-set-uint16-me seq offset x) ==> seq

           (binary-append-int32-le seq x) ==> seq
           (binary-append-int32-be seq x) ==> seq
           (binary-append-int32-me seq x) ==> seq
           (binary-ref-int32-le seq offset) ==> integer
           (binary-ref-int32-be seq offset) ==> integer
           (binary-ref-int32-me seq offset) ==> integer
           (binary-set-int32-le seq offset x) ==> seq
           (binary-set-int32-be seq offset x) ==> seq
           (binary-set-int32-me seq offset x) ==> seq

           (binary-append-uint32-le seq x) ==> seq
           (binary-append-uint32-be seq x) ==> seq
           (binary-append-uint32-me seq x) ==> seq
           (binary-ref-uint32-le seq offset) ==> integer
           (binary-ref-uint32-be seq offset) ==> integer
           (binary-ref-uint32-me seq offset) ==> integer
           (binary-set-uint32-le seq offset x) ==> seq
           (binary-set-uint32-be seq offset x) ==> seq
           (binary-set-uint32-me seq offset x) ==> seq

           (binary-append-int64-le seq x) ==> seq
           (binary-append-int64-be seq x) ==> seq
           (binary-append-int64-me seq x) ==> seq
           (binary-ref-int64-le seq offset) ==> integer
           (binary-ref-int64-be seq offset) ==> integer
           (binary-ref-int64-me seq offset) ==> integer
           (binary-set-int64-le seq offset x) ==> seq
           (binary-set-int64-be seq offset x) ==> seq
           (binary-set-int64-me seq offset x) ==> seq

           (binary-append-uint64-le seq x) ==> seq
           (binary-append-uint64-be seq x) ==> seq
           (binary-append-uint64-me seq x) ==> seq
           (binary-ref-uint64-le seq offset) ==> integer
           (binary-ref-uint64-be seq offset) ==> integer
           (binary-ref-uint64-me seq offset) ==> integer
           (binary-set-uint64-le seq offset x) ==> seq
           (binary-set-uint64-be seq offset x) ==> seq
           (binary-set-uint64-me seq offset x) ==> seq

Parameters: seq - binary
            x - integer in range, according to function requirement
            offset - fixnum, offset in binary object

Functions encode/decode integers within binary objects, according to specified
endianess:
  le - little endian
  be - big endian
  me - machine native endian
Append functions add integer to end of binary. Refer and set functions
decode/encode integers at specified offset.

15.2 binary-append-object
=========================
Function: (binary-append-object seq x) ==> seq

Parameters: seq - binary
            x - object: number, symbol, character, string, binary, vector or cons.

Converts object to binary machine-independed form and appends it to
binary. Object letter can be restored using 'binary-decode-object' function.

15.3 binary-decode-object
=========================
Function: (binary-decode-object seq offset) ==> object

Parameters: seq - binary
            offset - fixnum, offset where object resides.

Restores object from binary machine-independed form, previosly encoded with
'binary-append-object' function.



===============================================================================
16 Vector Functions
===============================================================================
16.1 vectorp
============
Function: (vectorp x) ==> bool

Parameters: x - object

Returns true if object is vector.

16.2 vector
===========
Function: (vector &rest args) ==> vector

Parameters: args - objects.

Creates new vector object and populates it with given objects.

16.3 vector-create
==================
Function: (vector-create size &key init-element max-capacity) ==> binary

Parameters: size - non negative fixnum
            init-element - object
            max-capacity - non negative fixnum

Creates new vector of given initial size and maximal capacity and fills it with
given initial element.

16.4 vector-length
==================
Function: (vector-length seq) ==> fixnum

Parameters: seq - vector

Returns length of vector.

16.5 vector-ref
===============
Function: (vector-ref seq pos) ==> object

Parameters: seq - vector
            pos - non negative fixnum

Returns element at 'pos' position of vector.

16.6 vector-set
===============
Function: (vector-set! seq pos val) ==> val

Parameters: seq - vector
            pos - non negative fixnum
            val - object

Sets value of nth element of vector to specified object.

16.7 vector-append
==================
Function: (vector-append seq x) ==> seq

Parameters: seq - vector
            x - object

Appends object to end of vector.

16.8 vector-append-list
=======================
Function: (vector-append-list dest src &optional count) ==> dest

Parameters: dest - destination vector
            src - source list
            count - non negative fixnum. Number of elements from source to add
              to destination. Whole list is added, if ommited.

Appends list to end of vector.

16.9 vector-append-vector
=========================
Function: (vector-append-vector dest src &key (src-offset 0) src-len) ==> dest

Parameters: dest - destination vector
            src - source vector
            src-offset - fixnum. Offset within source.
            src-len - number of elements in source to add to destination. If nil
              is passed, than whole source, starting from src-offset is added.

Appends vector to end of another vector.

16.10 vector-incr-capacity
==========================
Function: (vector-incr-capacity seq delta) ==> seq

Parameters: seq - vector
            delta - capacity delta, non negative fixnum

Ensures that 'delta' objects may be added to vector without storage
rellocations.

16.11 vector-clear
==================
Function: (vector-clear seq) ==> seq

Parameters: seq - vector

Erases all elements in vector.

16.12 vector-remove
===================
Function: (vector-remove seq start &optional count) ==> seq

Parameters: seq - vector
            start - start position, non negative fixnum.
            count - number of elements to remove, non negative fixnum. If count
            is nil, then vector is truncated from 'start' position.

Removes 'count' elements in vector starting from 'start' position.

16.13 vector-insert
===================
Function: (vector-insert seq pos x) ==> seq

Parameters: seq - vector
            pos - position to insert, non negative fixnum.
            x - object

Inserts object into vector at given position.

16.14 vector-insert-list
========================
Function: (vector-insert-list dest dest-pos src &optional count) ==> dest

Parameters: dest - destination vector
            dest-pos - position to insert, non negative fixnum.
            src - source list
            count - non negative fixnum. Number of elements from source to add
              to destination.

Inserts 'count' elements from list into vector at given position.

16.15 vector-insert-vector
==========================
Function: (vector-insert-vector dest dest-pos src &key (src-offset 0) src-len) ==> dest

Parameters: dest - destination vector
            dest-pos - position to insert, non negative fixnum.
            src - source vector
            src-offset - fixnum. Offset within source.
            src-len - number of elements in source to add to destination. If nil
              is passed, than whole source, starting from src-offset is added.

Inserts vector into another vector at given position.

16.16 vector-reverse
====================
Function: (vector-reverse seq &key (start 0) len) ==> seq

Parameters: seq - vector
            start - non negative fixnum. Start position to reverse
            len - non negative fixnum. Length of reversed sequence within
              original one.

Reverses vector in place.

16.17 vector-set-max-capacity
=============================
Function: (vector-set-max-capacity seq capacity) ==> seq

Parameters: seq - vector
            capacity - non negative fixnum. Must be greater or equal current
              vector length.

Limits maximal capacity of vector to given value.

16.18 vector-find
=================
Function: (vector-find seq obj &key (start 0) (test #'eql)) ==> fixnum or nil

Parameters: seq - vector
            obj - object
            start - fixnum
            test - function: (lambda x y) ==> bool. Returns true, if x is equal
              to y.

Searches vector for object from 'start' position. Return position or nil, if
object is not found.

16.19 vector-concat
===================
Function: (vector-concat seq &rest args) ==> seq

Parameters: seq - vector
            args - objects

Appends all arguments to vector.

16.20 vector-to-list
====================
Function: (vector-to-list seq &key (start 0) count) ==> list

Parameters: seq - vector
            start - fixnum. Start offset within object.
            count - number of vector elements to put in list.

Converts vector to list.

16.21 vector-sort
=================
Function: (vector-sort seq &key (start 0) count
                       (test (lambda (x y) (minusp (compare x y))))) ==> seq

Parameters: seq - vector
            start - fixnum. Start offset within object.
            count - number of vector elements to sort.
            test - function: (lambda x y) ==> bool. Returns true if x should be
              placed before y.

Sorts vector in place.

16.22 vector-stable-sort
========================
Function: (vector-stable-sort seq &key (start 0) count
                             (test (lambda (x y) (minusp (compare x y))))) ==> seq

Parameters: seq - vector
            start - fixnum. Start offset within object.
            count - number of vector elements to sort.
            test - function: (lambda x y) ==> bool. Returns true if x should be
              placed before y.

Sorts vector in place and preserves the relative order of the elements with
equivalent values.



===============================================================================
17 Conses Functions
===============================================================================
17.1 null
=========
Function: (null x) ==> bool

Parameters: x - object

Returns true, if x is nil.

17.2 consp
==========
Function: (consp x) ==> bool

Parameters: x - object

Returns true if object is cons.

17.3 list
=========
Function: (list &rest args) ==> list

Parameters: args - objects

Constructs fresh proper list from its arguments.

17.4 cons
=========
Function: (cons x y) ==> pair

Parameters: x - object
            y - object

Constructs cons object, which consists of objects x and y.

17.5 car
========
Function: (car x) ==> object

Parameters: x - pair

Returns car cell of cons.

17.6 cdr
========
Function: (cdr x) ==> object

Parameters: x - pair

Returns cdr cell of cons.

17.7 set-car
============
Function: (set-car x v) ==> v

Parameters: x - cons
            v - object

Sets car cell of cons.

17.8 set-cdr
============
Function: (set-cdr x v) ==> v

Parameters: x - cons
            v - object

Sets cdr cell of cons.

17.9 Compositions of car and cdr
================================
K-Lisp provides implementation for following compositions of car and cdr
functions:
  (caar x)        (car (car x))
  (cadr x)        (car (cdr x))
  (cdar x)        (cdr (car x))
  (cddr x)        (cdr (cdr x))
  (caaar x)       (car (car (car x)))
  (caadr x)       (car (car (cdr x)))
  (cadar x)       (car (cdr (car x)))
  (caddr x)       (car (cdr (cdr x)))
  (cdaar x)       (cdr (car (car x)))
  (cdadr x)       (cdr (car (cdr x)))
  (cddar x)       (cdr (cdr (car x)))
  (cdddr x)       (cdr (cdr (cdr x)))
  (caaaar x)      (car (car (car (car x))))
  (caaadr x)      (car (car (car (cdr x))))
  (caadar x)      (car (car (cdr (car x))))
  (caaddr x)      (car (car (cdr (cdr x))))
  (cadaar x)      (car (cdr (car (car x))))
  (cadadr x)      (car (cdr (car (cdr x))))
  (caddar x)      (car (cdr (cdr (car x))))
  (cadddr x)      (car (cdr (cdr (cdr x))))
  (cdaaar x)      (cdr (car (car (car x))))
  (cdaadr x)      (cdr (car (car (cdr x))))
  (cdadar x)      (cdr (car (cdr (car x))))
  (cdaddr x)      (cdr (car (cdr (cdr x))))
  (cddaar x)      (cdr (cdr (car (car x))))
  (cddadr x)      (cdr (cdr (car (cdr x))))
  (cdddar x)      (cdr (cdr (cdr (car x))))
  (cddddr x)      (cdr (cdr (cdr (cdr x))))

17.10 length
============
Function: (length seq) ==> integer

Parameters: seq - proper list

Returns length of proper list. If list contains loops, then error is signaled.

17.11 copy-list
===============
Function: (copy-list x) ==> list

Parameters: x - list

Returns 'shallow' (non-recursive) copy of list.

17.12 nreverse
==============
Function: (nreverse seq) ==> list

Parameters: seq - list

Destructivly reverses list in place.

17.13 reverse
=============
Function: (reverse seq) ==> list

Parameters: seq - list

Returns reverse non-recursive copy of list.

17.14 append
============
Function: (append &rest args) ==> list

Parameters: args - lists, but last argument may be atom

Append returns a new list that is the concatenation of the copies. Original
lists are left unchanged; the list structure of each of lists except the last
is copied. The last argument is not copied; it becomes the cdr of the final
dotted pair of the concatenation of the preceding lists, or is returned
directly if there are no preceding non-empty lists.

17.15 mapcar
============
Function: (mapcar fn &rest args) ==> list

Parameters: fn - function taking as many arguments as there are 'lists'.
            args - lists. All lists must be of same length.

Mapcar applies 'fn' element-wise to the elements of the lists and returns a list
of the results, in order from left to right.



===============================================================================
18 Low Level File I/O
===============================================================================
In K-Lisp file object is wrapper for OS file descriptor. All data writen and
read from files are binary. Files are automatically closed by K-Lisp when
collected by garbage collector. There are predefined variables '*stdin-file*',
'*stdout-file*' and '*stderr-file*' for standard file descriptors.

18.1 file-open
==============
Function: (file-open pathname flags &optional mode) ==> file

Parameters: pathname - string
            flags - integer, bitwise composition of flags, same as in 'open(2)'
              system call. Function 'file-open-flags' returns list of
              predefined symbolic constants for flags.
            mode - integer, bitwise composition of flags, same as in 'open(2)'
              system call. Function 'file-open-modes' returns list of
              predefined symbolic constants for modes.

The function is wrapper for 'open(2)' system call. Returns file. O_LARGEFILE
flag is always turned on by 'file-open' function.

18.2 file-open-flags
====================
Function: (file-open-flags) ==> list

Returns list of predefined symbolic constans for flags parameter of 'file-open'
function, like: O_RDONLY, O_WRONLY, O_RDWR, O_APPEND, O_CREAT, O_CLOEXEC,
O_DIRECT, O_DIRECTORY, O_EXCL, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK,
O_SYNC, O_TRUNC etc.

18.3 file-open-modes
====================
Function: (file-open-modes) ==> list

Returns list of predefined symbolic constans for mode parameter of 'file-open'
function, like: S_IRWXU, S_IRUSR, S_IWUSR, S_IXUSR, S_IRWXG, S_IRGRP, S_IWGRP,
S_IXGRP, S_IRWXO, S_IROTH, S_IWOTH, S_IXOTH etc.

18.4 file-create
================
Function: (file-create pathname mode) ==> file

Parameters: pathname - string
            mode - integer, bitwise composition of flags, same as in 'open(2)'
              system call. Function 'file-open-modes' returns list of
              predefined symbolic constants for modes.

Creates new file by calling (file-open pathname (bor O_CREAT O_WRONLY O_TRUNC) mode).

18.5 file-close
===============
Function: (file-close file) ==> nil

Parameters: file - file

The function is wrapper for 'close(2)' system call.

18.6 file-write
===============
Function: (file-write file buffer &key (offset 0) count) => integer or 'EAGAIN

Parameters: file -file
            buffer - binary.
            offset - fixnum. Offset within buffer.
            count - fixnum. Number of bytes in buffer to write to file. If nil
              is passed, than whole buffer, starting from offset is written.

The function is wrapper for 'write(2)' system call. Returns number of bytes
written to file. If file is in non-nblocking mode and write failed with EAGAIN
or EWOULDBLOCK error, then EAGAIN symbol is returned. If number of bytes to
write to file is greater than zero and no bytes are written, then
('zero-bytes-written count) signal is raised.

18.7 file-write-exact
=====================
Function: (file-write file buffer &key (offset 0) count) => file

Parameters: file -file
            buffer - binary.
            offset - fixnum. Offset within buffer.
            count - fixnum. Number of bytes in buffer to write to file. If nil
              is passed, than whole buffer, starting from offset is written.

Calls 'file-write' function in loop untill all required bytes are written in
file. Does not handle non-blocking files.

18.8 file-read
==============
Function: (file-read file buffer count) => integer or 'EAGAIN or nil

Parameters: file -file
            buffer - binary. Where to store read bytes. Read bytes are added to
               end of buffer.
            count - fixnum. Number of bytes to read from file.

The function is wrapper for 'read(2)' system call. Returns number of bytes
read from file. If file is in non-nblocking mode and read failed with EAGAIN
or EWOULDBLOCK error, then EAGAIN symbol is returned. If number of bytes to
read to file is greater than zero and no bytes are read, then nil is returned.

18.9 file-read-exact
====================
Function: (file-read file buffer count) => file

Parameters: file -file
            buffer - binary. Where to store read bytes. Read bytes are added to
               end of buffer.
            count - fixnum. Number of bytes to read from file.

Calls 'file-read' function in loop untill all required bytes are read from
file. Does not handle non-blocking files.

18.10 file-pwrite
=================
Function: (file-write file buffer f-offset &key (b-offset 0) count) => integer or 'EAGAIN

Parameters: file -file
            buffer - binary.
            f-offset - integer. File offset from the beginning of the file.
            b-offset - fixnum. Offset within buffer.
            count - fixnum. Number of bytes in buffer to write to file. If nil
              is passed, than whole buffer, starting from offset is written.

The function is wrapper for 'pwrite(2)' system call. Returns number of bytes
written to file. If file is in non-nblocking mode and write failed with EAGAIN
or EWOULDBLOCK error, then EAGAIN symbol is returned. If number of bytes to
write to file is greater than zero and no bytes are written, then
('zero-bytes-written count) signal is raised.

18.11 file-pwrite-exact
=======================
Function: (file-write-exact file buffer f-offset &key (b-offset 0) count) => file

Parameters: file -file
            buffer - binary.
            f-offset - integer. File offset from the beginning of the file.
            b-offset - fixnum. Offset within buffer.
            count - fixnum. Number of bytes in buffer to write to file. If nil
              is passed, than whole buffer, starting from offset is written.

Calls 'file-pwrite' function in loop untill all required bytes are written in
file. Does not handle non-blocking files.

18.12 file-pread
================
Function: (file-pread file buffer count offset) => integer or 'EAGAIN or nil

Parameters: file -file
            buffer - binary. Where to store read bytes. Read bytes are added to
               end of buffer.
            count - fixnum. Number of bytes to read from file.
            offset - integer. File offset from the beginning of the file.

The function is wrapper for 'pread(2)' system call. Returns number of bytes
read from file. If file is in non-nblocking mode and read failed with EAGAIN
or EWOULDBLOCK error, then EAGAIN symbol is returned. If number of bytes to
read to file is greater than zero and no bytes are read, then nil is returned.

18.13 file-pread-exact
======================
Function: (file-pread-exact file buffer count offset) => file

Parameters: file -file
            buffer - binary. Where to store read bytes. Read bytes are added to
               end of buffer.
            count - fixnum. Number of bytes to read from file.
            offset - integer. File offset from the beginning of the file.

Calls 'file-pread' function in loop untill all required bytes are read from
file. Does not handle non-blocking files.

18.14 file-seek
===============
Function: (file-seek file offset whence) ==> integer

Parameters: file - file
            offset - integer. File offset according to directive whence as
              following:
                SEEK_SET - the offset is set to offset bytes.
                SEEK_CUR - the offset is set to its current location plus offset
                  bytes.
                SEEK_END - the offset is set to the size of the file plus offset bytes.
            whence - symbol.

The function is wrapper for 'lseek(2)' system call. Sets file read/write
position. Returns the resulting offset location as measured in bytes from the
beginning of the file.

18.15 file-tell
===============
Function: (file-tell file) ==> integer

Parameters: file - file

Returns current positinio of the file. Calls (file-seek file 0 'SEEK_CUR).

18.16 file-sync
===============
Function: (file-sync file) ==> file

Parameters: file - file

The function is wrapper for 'fsync(2)' system call.

18.17 file-datasync
===================
Function: (file-datasync file) ==> file

Parameters: file - file

The function is wrapper for 'fdatasync(2)' system call.

18.18 file-access
=================
Function: (file-access pathname mode) ==> bool

Parameters: pathname - string

            mode - integer, either F_OK or bitwise composition of flags (W_OK,
              R_OK, X_OK), same as in 'access(2)' system call. Function
              'file-access-modes' returns list of predefined symbolic constants
              for modes.

The function is wrapper for 'access(2)' system call.

18.18 file-access-modes
=======================
Function: (file-access-modes) ==> list

Returns list of predefined symbolic constans for flags parameter of 'file-access'
function, like: F_OK, W_OK, R_OK, X_OK.



===============================================================================
19 File System Interface
===============================================================================

===============================================================================
20 Pipes and FIFOs
===============================================================================

===============================================================================
21 Basic Program/System interface
===============================================================================
21.1 *argv*
===========
Program arguments are stored in global variable '*argv*'.

21.2 getenv
===========
Function: (getenv name &optional default) ==> string or default

Parameters: name - string
            default - object

The function is wrapper for C 'getenv' function. If environment variable is not
present, then 'default' parameter is returned.

21.3 setenv
===========
Function: (setenv name value overwrite) ==> name

Parameters: name - string
            value - string
            overwrite - boolean

The function is wrapper for C 'setenv' function.

21.4 unsetenv
=============
Function: (unsetenv name) ==> name

Parameters: name - string

The function is wrapper for C 'unsetenv' function.

21.5 clearenv
=============
Function: (clearenv) ==> nil

Parameters: none

The function is wrapper for C 'clearenv' function.


**************


===============================================================================
20 Processes
===============================================================================
20.1 which
==========
Function: (which name) ==> string or nil

Parameters: name - string

Locates executable, like 'which' command line utility



===============================================================================
5 Common Functions
===============================================================================
Common functions operate on objects of any type. All common functions reside in
'kl' package.

5.1 type-of
===========
Function: (type-of x) ==> symbol

Parameters: x - object

Returns symbol of x's type:
  'nil - nil
  'char - character
  'fixnum - fixnum integer
  'bigint - big integer
  'double - floating point of double precision
  'symbol - symbol
  'lambda - lambda
  'macro - macro
  'binary - binary
  'string - string
  'cons - cons
  'vector - vector
  'custom - non-standard K-Lisp type, provided by native extension library.

5.4 eq
=======
Function: (eq x y) ==> bool

Parameters: x - object
            y - object

It is necessary to know how K-Lisp objects are represented internally in
computer, in order to understand 'eq' function.

All objects in K-Lisp are referenced by machine word. Each machine word
associated with K-Lisp object has type tag. K-Lisp reserves 3 lower bits of
machine word for type tag.  Objects those fit remaining bits of machine word are
stored immediately in that word, while other are stored in some location of
computer memory and address to that location is stored in machine
word.

Nil, small integers (fixnums) and characters are always stored in machine word
by K-Lisp. Objects of other types are represented by their address in computer
memory.

Function 'eq' is fastest comparison function and just compares two machine words
that represent K-Lisp objects. It returns true, if they are equal. That means it
returns true, if both objects are nil, or both objects are same small integers
or characters, or they address same identical memory addres of K-Lisp object.

Examples:
  (eq () ())       ; t
  (eq 'x 'x)       ; t
  (eq 'x 'y)       ; nil
  (eq (symbol "x") (symbol "x")) ; nil
  (eq '(1) '(1))   ; undefined
  (eq (list 1) (list 1)) ; nil
  (eq 0 0)         ; t, because computer requires at least three words of
                    ; memory to hold that expression. So at least 2-bits will be
                    ; available for fixnums. And integers in range [-2, 1] are
                    ; always stored in machine word.
  (eq 2 2)         ; undefined
  (eq "" "")       ; undefined
  (eq #(1) #(1))     ; undefined
  (eq #"a" #"a")   ; undefined

5.5 eql
========
Function: (eql x y) ==> bool

Parameters: x - object
            y - object

The value of 'eql' is true of two objects, x and y, in the folowing cases:
  1. If x and y are 'eq'.
  2. If x and y are both characters with the same value.
  3. If x and y are both numbers of the same type and the same value.
Otherwise the value of 'eql' is false.

5.6 equal
==========
Function: (equal x y) ==> bool

Parameters: x - object
            y - object

The value of 'equal' is true of two objects, x and y, in the folowing cases:
  1. If x and y are 'eql'.
  2. x and y are numbers and are numerically equal.
  3. If x and y are containers of same type and same size, and each element of x
     is 'equal' to corresponding element of y.
Otherwise the value of 'equal' is false.

5.7 Comparison Functions
========================
Objects of different types in K-Lisp are comapred according to following rules:
  nil < char < number < symbol < binary < string < vector < pair

Symbols are compared by their packages first. If packages are equal, then symbols
are compared by names.

Containers objects of same type are compared lexicographically.

Objects of other types may be tested for equalence only with 'eq', 'eql' or 'equal'
functions.

5.7.3 compare
=============
Function: (compare x y) ==> number

Parameters: x - one of: nil, char, number, symbol, binary, string, vector or pair
            y - one of: nil, char, number, symbol, binary, string, vector or pair

Returns negative number if x < y, positive number if x > y and zero if x equal
to y.

5.10 not
========
Function: (not x) ==> bool

Parameters: x - object

Performs boolen not operation for object x: if x is nil, then true is returned,
otherwise nil is returned.

5.13 def-global-var
===================
Function: (def-global-var s v) ==> s

Parameters: s - symbol
            v - object

Binds value slot of symbol s to v and adds symbol s to roots of garbage
collector.

5.14 undef-global-var
=====================
Function: (undef-global-var s) ==> object

Parameters: s - symbol

Unbinds value slot of symbol s. If both value slot and function slot are
unbound, then symbol is removed from roots of garbage collector. Returns symbol
value before unbinding.

5.15 def-global-fun
===================
Function: (def-global-fun s f) ==> s

Parameters: s - symbol
            f - expression, which evaluates to lambda or macro

Binds function slot of symbol s to result of f and protects symbol s from
garbage collection.

5.32 undef-global-fun
=====================
Function: (undef-global-fun s) ==> s

Parameters: s - symbol

Unbinds function slot of symbol s. If both value slot and function slot are
unbound, then symbol is removed from roots of garbage collector.

5.27 macro?
===========
Function: (macro? x) ==> bool

Parameters: x - object

Returns true, if object is macro.

5.28 lambda?
============
Function: (lambda? x) ==> bool

Parameters: x - object

Returns true, if object is lambda.

5.29 custom?
============
Function: (custom? x) ==> bool

Parameters: x - object

Returns true if object has custom type.



===============================================================================
14 Procedure Functions
===============================================================================
14.1 eval
=========
Function: (eval exp) ==> object

Parameters: exp - object

Evaluates expression in null lexical environment. Expression is automatically
compiled before evaluation.

14.2 funcall
============
Function: (funcall fn &rest args) ==> object

Parameters: fn - functional object
            args - arguments passed to fn

Calls function fn and passes args to it.

14.3 apply
==========
Function: (apply fn args) ==> object

Parameters: fn - procedure object
            args - list of arguments passed to procedure

Calls procedure fn and passes args to it.

14.4 macro-env
==============
Function: (macro-env) ==> object

Returns compiler's lexical environment, in which macro is expanded by
compiler. Returned environment may be passed to functions: macroexpand,
macroexpand-all, macro-function? and macro-symbol?.

14.5 macroexpand-1
==================
Function: (macroexpand-1 exp (env nil)) ==> object

Parameters: exp - expression (list)
            env - nil or lexical environment, returned by 'macro-env' special form.

If exp represents macro call or macro symbol defined in given lexical environment,
then it is expanded once.

14.6 macroexpand
================
Function: (macroexpand exp (env nil)) ==> object

Parameters: exp - expression (list)
            env - nil or lexical environment, returned by 'macro-env' special form.

Expands expression 'exp' recursively, until it represents macro call or macro
symbol defined in given lexical environment.

14.7 macroexpand-all
====================
Function: (macroexpand-all exp (env nil)) ==> object

Parameters: exp - expression (list)
            env - nil or lexical environment, returned by 'macro-env' special form.

Expands recursively all macros in expression.

14.8 macro-function?
====================
Function: (macro-function? name env) ==> bool

Parameters: name - symbol
            env - lexical environment, returned by 'macro-env' special form.

Returns true, if name is macro in given lexical environment.

14.9 macro-symbol?
==================
Function: (macro-symbol? name env) ==> bool

Parameters: name - symbol
            env - lexical environment, returned by 'macro-env' special form.

Returns true, if name is a symbol macro, defined with 'symbol-macrolet' in given
lexical environment.

14.10 load
=========
Function: (load path) ==> object

Parameters: path - string.

Loads and evaluates all expressions in file in null lexical environment. Returns
value of las evaluated expression.

14.11 function-lambda-list
==========================
Function: (function-lambda-list fn) ==> object

Parameters: fn - lambda, macro or closure.

Returns lambda list of functional object.

14.12 function-body
===================
Function: (function-body fn) ==> object

Parameters: fn - lambda, macro or closure.

Returns body of functional object.

14.13 function-compiled-lambda-list
===================================
Function: (function-lambda-list fn) ==> object

Parameters: fn - lambda, macro or closure.

Returns compiled lambda list of functional object.

14.14 function-compiled-body
============================
Function: (function-body fn) ==> object

Parameters: fn - lambda, macro or closure.

Returns compiled body of functional object.

return - macro
apply-vec - function


===============================================================================
15 Low Level File Functions
===============================================================================
File functions provide interface to low level OS file operations. Files are
objects of custom type. There are 3 standard files: stdin, stdout and
stderr. And they are stored in predefined global variables: *file-stdin*,
*file-stdout* and *file-stderr*.

15.1 file-open
==============
Function: (file-open path modes (perms #o644)) ==> file

Parameters: path - string, path to file. If path is not absolute, then absolute path
                   is constructed, using current working directory, stored in
                   *current-directory* global variable.
            modes - list, of one or more following terms 'read, 'write,
                    'append.
            perms - permissions of file.

Opens the file 'path' in the mode determined by 'modes' list, which may contain
one or more of the following items:
  'read - The file, which must exist, is opened for reading.
  'write - The file is opened for writing. It is created if it does not
           exist. If the file exists, and if 'write is not combined with
           'read, the file will be truncated.
  'append - The file will be opened for writing, and it will be created if
            it does not exist. Every write operation to a file opened with
            'append will take place at the end of the file.
File is closed automatically by garbage collector, but it is recommended to
close it explicitly with file-close function.

15.2 file-close
===============
Function: (file-close file) ==> nil

Parameters: file - file

Closes file.

15.3 file-write
===============
Function: (file-write file data) ==> file

Parameters: file - file object returned by file-open.
            data - binary.

Writes all data to file. Data are written at current file offset.

15.4 file-pwrite
================
Function: (file-pwrite file data offset) ==> file

Parameters: file - file object returned by file-open.
            data - binary.
            offset - integer, absolute file position.

Writes all data to the file at given offset in one shot. The file offset is
not changed.

15.5 file-read
==============
Function: (file-read file count) ==> binary or *eof*

Parameters: file - file object returned by file-open.
            count - integer, number of bytes to read.

Reads maximum 'count' bytes from file at current file offset. Number of bytes
may be less, then required. If end of file is reached, then value of global
variable *eof* is returned.

15.6 file-pread
===============
Function: (file-pread file count offset) ==> binary or *eof*

Parameters: file - file object returned by file-open.
            count - integer, number of bytes to read.
            offset - integer, absolute file position.

Reads exact 'count' bytes from file at given offset in one shot. The file offset
is not changed. If end of file is reached, then value of global variable *eof*
is returned.

15.7 file-fsync
===============
Function: (file-fsync file) ==> file

Parameters: file - file object returned by file-open.

Flushes modified data to disk device. The call blocks until the device reports
that the transfer has completed. It also flushes metadata information associated
with the file.

15.8 file-fdatasync
===================
Function: (file-fdatasync file) ==> file

Parameters: file - file object returned by file-open.

fdatasync is similar to fsync, but does not flush modified metadata unless that
metadata is needed in order to allow a subsequent data retrieval to be correctly
handled.

15.9 file-lseek
===============
Function: (file-lseek file offset whence) ==> integer

Parameters: file - file object returned by file-open.
            offset - integer.
            whence - symbol, one of following
               'seek-set - the offset is set to offset bytes.
               'seek-cur - the offset is set to its current location plus
                           offset bytes.
               'seek-end - the offset is set to the size of the file plus
                           offset bytes.

The lseek function repositions the offset of the open file to the argument
'offset' according to the directive 'whence'.



===============================================================================
16 Timer Functions
===============================================================================
16.1 monotonic-timer-resolution
=================================
Function: (monotonic-timer-resolution) ==> integer

Returns resolution of builtin monotonic system timer in nanoseconds (10^−9 sec).
See clock_getres(CLOCK_MONOTONIC) in Linux man pages.

16.2 monotonic-timer-value
============================
Function: (monotonic-timer-value) ==> integer

Returns current value of builtin monotonic timer in nanoseconds (10^−9 sec).
See clock_getres(CLOCK_MONOTONIC) in Linux man pages.



===============================================================================
17 Streaming Input Output Functions
===============================================================================
17.1 read
=========
Function: (read (stream *stdin*)) ==> object

Parameters: stream - input stream.

Reads printed representation of K-Lisp object from stream and returns parsed
object. If end of stream is encountered, then value of global variable *eof* is
returned.

17.2 print
==========
Function: (print x (stream *stdout*)) ==> x

Parameters: x - object.
            stream - stream.

Prints object to stream. Object is printed in form suitable for latter parsing
by read function.

17.3 pprint
===========
Function: (pprint x (stream *stdout*)) ==> x

Parameters: x - object.
            stream - stream.

Pretty prints object to stream. Object is printed in form suitable for latter parsing
by read function. Builtin macros like quote and quasiquote are represented as '
and `, etc.

17.4 write
==========
Function: (write bin (stream *stdout*)) ==> bin

Parameters: bin - binary
            stream - stream

Writes binary object into stream.



===============================================================================
18 Hashmap functions
===============================================================================
Hashmaps are implemented as custom objects and represents hash tables capable to
store any standard K-Lisp object as key. Hash code of key object is calculated
by internal non-public function and function user supplied function is used to
compare keys. Hashmaps are destroyed automatically by garbage collector.

18.1 hashmap-make
=================
Function: (hashmap-make (test #'equal)) ==> hashmap

Parameters: test - function, which compares two objects and returns bool, like
                   'equal'.

Creates new hashmap.

18.2 hashmap-insert
===================
Function: (hashmap-insert tbl key value) => (old-key . old-value) or nil

Parameters: tbl - hashmap
            key - object. The key is marked as immutable before inserting into
                  hashmap.
            value -object

Inserts key/value pair into hashmap. Returns old pair, if pair with such key already
was in hashmap, then its value is updated. Key is not replaced.

18.3 hashmap-lookup
===================
Function: (hashmap-lookup tbl key (not-found nil)) ==> object

Parameters: tbl - hashmap
            key - object
            not-found - object returned in case, when key is not found in map.

Searches hashmap for given key and returns value assotiated with it.  If key is
not found, then value of not-found parameter is returned.

18.4 hashmap-remove
===================
Function: (hashmap-remove tbl key) ==> (old-key . value) or nil

Parameters: tbl - hashmap
            key - object

Removes key from hashmap. Returns key/value pair if key, was in map.

18.5 hashmap-size
=================
Function: (hashmap-size tbl) ==> integer

Parameters: tbl - hashmap

Returns size of hashmap.

18.6 hashmap-clear
==================
Function: (hashmap-clear tbl) ==> tbl

Parameters: tbl - hashmap

Removes all key/value pairs from hashmap.



===============================================================================
19 Treemap functions
===============================================================================
Treemaps are implemented as custom objects and represents binary trees capable
to store any standard K-Lisp object as key. User supplied function is used to
compare keys. Treemaps are destroyed automatically by garbage collector.

19.1 treemap-make
=================
Function: (treemap-make (test #'<)) ==> treemap

Parameters: test - function, which compares two objects and returns bool, like
                   '<'.

Creates new treemap.

19.2 treemap-insert
===================
Function: (treemap-insert tbl key value) => (key . old-value) or nil

Parameters: tbl - treemap
            key - object. The key is marked as immutable before inserting into
                  treemap.
            value -object

Inserts key/data pair into treemap. Returns true, if pair with such key already
was in treemap, then its value is updated. Key is not replaced.

19.3 treemap-lookup
===================
Function: (treemap-lookup tbl key (not-found nil)) ==> object

Parameters: tbl - treemap
            key - object
            not-found - object returned in case, when key is not found in map.

Searches treemap for given key and returns value assotiated with it.  If key is
not found, then value of global variable *eof* is returned.

19.4 treemap-remove
===================
Function: (treemap-remove tbl key) ==> (key . value) or nil

Parameters: tbl - treemap
            key - object

Removes key from treemap. Returns key/value pair if key, was in map.

19.5 treemap-size
=================
Function: (treemap-size tbl) ==> integer

Parameters: tbl - treemap

Returns size of treemap.

19.6 treemap-clear
==================
Function: (treemap-clear tbl) ==> tbl

Parameters: tbl - treemap

Removes all key/value pairs from treemap.



===============================================================================
20 File system functions
===============================================================================
20.1 absolute-path?
===================
Function: (absolute-path? path) ==> bool

Parameters: path - string

Returns true if path is absolute.

20.2 absolute-path
==================
Function: (absolute-path path) ==> string

Parameters: path - string.

Constructs absolute path by adding current working directory, stored in
*current-directory*, to supplied path. If supplied path is already absolute,
does nothing.
